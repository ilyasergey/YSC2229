

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>12.2. Representing Graphs &mdash; YSC2229 2019</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="12.3. Exercises" href="week-12_exercises.html" />
    <link rel="prev" title="12.1. Representing Sets via Binary Search Trees" href="week-12_bst.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> YSC2229: Introductory Data Structures and Algorithms
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-01.html">1. YSC2229 Lecture Notes, Week 01</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-02.html">2. YSC2229 Lecture Notes, Week 02</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-03.html">3. YSC2229 Lecture Notes, Week 03</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-04.html">4. YSC2229 Lecture Notes, Week 04</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-05.html">5. YSC2229 Lecture Notes, Week 05</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-06.html">6. YSC2229 Lecture Notes, Week 06</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-midterm-tasks.html">7. YSC2229: Midterm Project, Week 07</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-08.html">8. YSC2229 Lecture Notes, Week 08</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-09.html">9. YSC2229 Lecture Notes, Week 09</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-10.html">10. YSC2229 Lecture Notes, Week 10</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-11.html">11. YSC2229 Lecture Notes, Week 11</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="YSC2229-lecture-notes-week-12.html">12. YSC2229 Lecture Notes, Week 12</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="week-12_bst.html">12.1. Representing Sets via Binary Search Trees</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">12.2. Representing Graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graphs-as-adjacency-lists">12.2.1. Graphs as Adjacency Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reading-and-printing-graphs">12.2.2. Reading and Printing Graphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rendering-graphs-via-graphviz">12.2.3. Rendering Graphs via GraphViz</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shortcomings-of-adjacency-list-graph-representation">12.2.4. Shortcomings of Adjacency-List graph representation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graphs-as-linked-data-structures">12.2.5. Graphs as Linked Data Structures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#switching-between-graph-representations">12.2.6. Switching between graph representations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-graph-operations">12.2.7. Testing graph operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week-12_exercises.html">12.3. Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-13.html">13. YSC2229 Lecture Notes, Week 13</a></li>
<li class="toctree-l1"><a class="reference internal" href="YSC2229-lecture-notes-week-14.html">14. YSC2229 Lecture Notes, Week 14</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">YSC2229: Introductory Data Structures and Algorithms</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="YSC2229-lecture-notes-week-12.html">12. YSC2229 Lecture Notes, Week 12</a> &raquo;</li>
        
      <li>12.2. Representing Graphs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="representing-graphs">
<span id="graphs"></span><h1>12.2. Representing Graphs<a class="headerlink" href="#representing-graphs" title="Permalink to this headline">¶</a></h1>
<p><a class="reference external" href="https://github.com/ilyasergey/ysc2229-part-two/blob/master/lib/week_12_Graphs.ml">https://github.com/ilyasergey/ysc2229-part-two/blob/master/lib/week_12_Graphs.ml</a></p>
<p>Graphs are an important versatile mathematical abstractions, which is used to represent the relations between multiple objects. Such (possibly non-symeetric) relations can be frequently phrased in terms of <em>connectivity</em> and <em>reachability</em>, as we’ve seen before in the chapter on <a class="reference internal" href="week-11_union_find.html#union-find"><span class="std std-ref">Equivalance Classes and Union-Find</span></a>.</p>
<p>A graph is commonly represented in mathematics by a pair <span class="math notranslate nohighlight">\(G = (V, E)\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is a set of the graphs’s vertices (nodes), represented the related elements, and <span class="math notranslate nohighlight">\(E\)</span> is a set of its edges (arcs) such that <span class="math notranslate nohighlight">\(E \subseteq V \times V\)</span>.</p>
<p>As some graph exampes, <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(E\)</span> can represent correspondingly:</p>
<ul class="simple">
<li>Cities and roads between them</li>
<li>Routers in the networks and connections between them</li>
<li>Statements in a program and a control-flow transitions</li>
<li>Control states of a machine and transitions between them</li>
<li>“Friendship” relations between users of a social network</li>
</ul>
<p>It is commont to think of <span class="math notranslate nohighlight">\(V\)</span> to be represented by a segment <span class="math notranslate nohighlight">\(\{0 ... (n - 1)\}\)</span> of natural numbers for some <span class="math notranslate nohighlight">\(n\)</span> (so that <span class="math notranslate nohighlight">\(n\)</span> is the size of the set of vertices). However, if the nodes carry additional meaning (e.g., the name of the city), one can define their payload as a function <span class="math notranslate nohighlight">\(\{0 ... (n - 1)\} \rightarrow P\)</span> for some set of payload values <span class="math notranslate nohighlight">\(P\)</span>. Edges can be also given labels in a similar way by defining a function <span class="math notranslate nohighlight">\(E \rightarrow L\)</span> for some label set <span class="math notranslate nohighlight">\(L\)</span>.</p>
<div class="section" id="graphs-as-adjacency-lists">
<h2>12.2.1. Graphs as Adjacency Lists<a class="headerlink" href="#graphs-as-adjacency-lists" title="Permalink to this headline">¶</a></h2>
<p>Here is the first take on representing graphs as data s structure – by means of <em>adjacency lists</em> (AL). In this representation an each node (a natural number) <code class="docutils literal notranslate"><span class="pre">u</span></code> points (e.g., as an element of an array) to a list of other nodes <code class="docutils literal notranslate"><span class="pre">v</span></code>, that are immediately <em>reachable</em> from <code class="docutils literal notranslate"><span class="pre">u</span></code>, i.e., the graph <code class="docutils literal notranslate"><span class="pre">g</span></code> has an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code>.</p>
<p>For instance, consider the following graph:</p>
<a class="reference internal image-reference" href="_images/small.png"><img alt="_images/small.png" class="align-center" src="_images/small.png" style="width: 400px;" /></a>
<p>It has 6 nodes (numbered 0-5) and can be encoded via the following array:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">[|[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">3</span><span class="o">];</span>
  <span class="o">[</span><span class="mi">4</span><span class="o">;</span> <span class="mi">2</span><span class="o">];</span>
  <span class="o">[</span><span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">];</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="bp">[]</span><span class="o">;</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">5</span><span class="o">]|]</span>
</pre></div>
</div>
<p>That is, for instance, the node 5 has nodes 1 and also itself as its <em>next</em> (successors) nodes, immediately reachable via the corresponding edges.</p>
<p>Keeping in mind the possibility of adding payload to nodes and labels to edges, we arrange the graph as the following type <code class="docutils literal notranslate"><span class="pre">graph</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">AdjacencyGraphs</span> <span class="o">=</span> <span class="k">struct</span>

  <span class="k">type</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">size</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
    <span class="n">adj</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="kt">array</span><span class="o">;</span>
    <span class="n">node_payloads</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="kt">list</span> <span class="n">ref</span><span class="o">;</span>
    <span class="n">edge_labels</span> <span class="o">:</span> <span class="o">((</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="kt">list</span> <span class="n">ref</span>
  <span class="o">}</span>

  <span class="k">let</span> <span class="n">mk_graph</span> <span class="n">n</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="bp">[]</span><span class="o">;</span>
    <span class="n">node_payloads</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span><span class="o">;</span>
    <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c">(* More functions come here *)</span>

<span class="k">end</span>
</pre></div>
</div>
<p>Creating a graph allocates <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes, but does not add anye edges. As graphs are an inherently imperative (i.e., mutable) structure, we can add edges as follows by changing the corresponding componnents of the adjacency array:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add_edge</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="o">=</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">in_range</span> <span class="n">g</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">in_range</span> <span class="n">g</span> <span class="n">dst</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">src</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">out&#39;</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="n">out</span> <span class="k">in</span>
  <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">src</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">dst</span> <span class="o">::</span> <span class="n">out&#39;</span>
</pre></div>
</div>
<p>That is, the procedure above adds the edges <code class="docutils literal notranslate"><span class="pre">(src,</span> <span class="pre">dst)</span></code> to the graph <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
<p>Removing edges or adding labels to them can be achieved in a similar way:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">remove_edge</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="o">=</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">in_range</span> <span class="n">g</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">in_range</span> <span class="n">g</span> <span class="n">dst</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">src</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">out&#39;</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="n">out</span> <span class="k">in</span>
  <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">src</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">out&#39;</span>

<span class="k">let</span> <span class="n">set_edge_label</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">in_range</span> <span class="n">g</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">in_range</span> <span class="n">g</span> <span class="n">dst</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">labs</span> <span class="o">=</span> <span class="o">!(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_labels</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">labs&#39;</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">((</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">),</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">&lt;&gt;</span> <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">))</span> <span class="n">labs</span> <span class="k">in</span>
  <span class="n">g</span><span class="o">.</span><span class="n">edge_labels</span> <span class="o">:=</span> <span class="o">((</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">),</span> <span class="n">l</span><span class="o">)</span> <span class="o">::</span> <span class="n">labs&#39;</span>
</pre></div>
</div>
<p>It is not uncommon to need to have the whole set of edges. We can obtain it as follows, byt traversing the entire adjacency array, returning the list of edges:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">edges</span> <span class="n">g</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nn">Week_06</span><span class="p">.</span><span class="nc">DLLBasedQueue</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mk_queue</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">enqueue</span> <span class="n">q</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="n">next</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="n">queue_to_list</span> <span class="n">q</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-and-printing-graphs">
<h2>12.2.2. Reading and Printing Graphs<a class="headerlink" href="#reading-and-printing-graphs" title="Permalink to this headline">¶</a></h2>
<p>Let us now suggest a way to input graphs, so they would be converted to the programmatic representation. One way to do so is to provide a size of a graph (in terms of nodes), as well as all pairs, indicating the directed edges. For instance, the graph above can be defined by the following list of strings, where the first one is its size:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">small_graph_shape</span> <span class="o">=</span>
  <span class="o">[</span><span class="s2">&quot;6&quot;</span><span class="o">;</span>
   <span class="s2">&quot;0 1&quot;</span><span class="o">;</span>
   <span class="s2">&quot;0 3&quot;</span><span class="o">;</span>
   <span class="s2">&quot;3 1&quot;</span><span class="o">;</span>
   <span class="s2">&quot;1 4&quot;</span><span class="o">;</span>
   <span class="s2">&quot;1 2&quot;</span><span class="o">;</span>
   <span class="s2">&quot;2 4&quot;</span><span class="o">;</span>
   <span class="s2">&quot;2 5&quot;</span><span class="o">;</span>
   <span class="s2">&quot;5 1&quot;</span><span class="o">;</span>
   <span class="s2">&quot;5 5&quot;</span><span class="o">]</span>
</pre></div>
</div>
<p>Using the functions from the previous weeks, we can convert this list to a graph, in which node payloads are the same as node identifiers (i.e., natural numbers) using the following function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">adjacency_int_graph_of_strings</span> <span class="n">ls</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="n">trimmer</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">ls</span><span class="o">)</span> <span class="o">|&gt;</span> <span class="n">int_of_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">g</span> <span class="o">=</span> <span class="n">mk_graph</span> <span class="n">size</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">edges</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="n">ls</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pairs</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">trimmer</span> <span class="n">s</span><span class="o">)</span> <span class="n">edges</span> <span class="o">|&gt;</span>
              <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">|&gt;</span>
              <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span>
                <span class="k">let</span> <span class="n">splitted</span> <span class="o">=</span> <span class="n">splitter</span> <span class="n">s</span> <span class="k">in</span>
                <span class="k">let</span> <span class="n">src</span> <span class="o">=</span> <span class="n">int_of_string</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">splitted</span> <span class="k">in</span>
                <span class="k">let</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">int_of_string</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="n">splitted</span> <span class="k">in</span>
                <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">))</span>
  <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">set_payload</span> <span class="n">g</span> <span class="n">i</span> <span class="n">i</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">add_edge</span> <span class="n">g</span> <span class="n">s</span> <span class="n">d</span><span class="o">)</span> <span class="n">pairs</span><span class="o">;</span>
  <span class="n">g</span>
</pre></div>
</div>
<p>In the same way, we can read a graph from the file (hence the string-based representation):</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">read_simple_graph_shape_from_file</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">read_file_to_strings</span> <span class="n">filename</span> <span class="k">in</span>
  <span class="n">adjacency_int_graph_of_strings</span> <span class="n">ls</span>
</pre></div>
</div>
<p>Finally, we can dump a simple graph with no payloads into a file using the following pair of functions:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">graph_to_string</span> <span class="n">g</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">string_of_int</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ls</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;%d %d&quot;</span> <span class="n">s</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">edges</span> <span class="n">g</span><span class="o">)</span> <span class="k">in</span>
  <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">s0</span> <span class="o">::</span> <span class="n">ls</span><span class="o">)</span>

<span class="c">(* Dump graph to file *)</span>
<span class="k">let</span> <span class="n">wirte_simple_graph_shape_to_file</span> <span class="n">filename</span> <span class="n">g</span> <span class="o">=</span>
  <span class="n">graph_to_string</span> <span class="n">g</span> <span class="o">|&gt;</span>
  <span class="n">write_string_to_file</span> <span class="n">filename</span>
</pre></div>
</div>
<p><strong>Question:</strong> How would you suggest to serialise graphs with non-trivial payloads on nodes and labels on edges?</p>
</div>
<div class="section" id="rendering-graphs-via-graphviz">
<h2>12.2.3. Rendering Graphs via GraphViz<a class="headerlink" href="#rendering-graphs-via-graphviz" title="Permalink to this headline">¶</a></h2>
<p>The simples way to visualise graphs in a nice form is to use a third-party tool <a class="reference external" href="https://www.graphviz.org/">GraphViz</a>. As input, GraphViz accepts a text file in a special format, which it can then convert to an image of a graph, taking care of positioning the nodes and rendering the edges between them. Some examples ony using GraphViz can be found by <a class="reference external" href="https://graphs.grevian.org/example">this link</a>.</p>
<p>The following functions transform a graph, represented by adjacency lists to a GraphViz-formatted string and write it to the file:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">graphviz_string_of_graph</span> <span class="n">gtyp</span> <span class="n">conn</span> <span class="n">vattrib</span> <span class="n">eattrib</span> <span class="n">g</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">preamble</span> <span class="o">=</span> <span class="n">gtyp</span> <span class="o">^</span> <span class="s2">&quot; {</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">epilogue</span> <span class="o">=</span> <span class="s2">&quot;}&quot;</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">body</span> <span class="o">=</span>
    <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">edges</span> <span class="n">g</span> <span class="o">|&gt;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;%s %s %s %s&quot;</span>
          <span class="o">(</span><span class="n">vattrib</span> <span class="n">s</span><span class="o">)</span> <span class="n">conn</span> <span class="o">(</span><span class="n">vattrib</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">eattrib</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)))</span> <span class="o">|&gt;</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="s2">&quot;;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="k">in</span>
  <span class="n">preamble</span> <span class="o">^</span> <span class="n">body</span> <span class="o">^</span> <span class="n">epilogue</span>

<span class="k">let</span> <span class="n">graphviz_no_payload</span> <span class="n">g</span> <span class="n">out</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">graphviz_string_of_graph</span> <span class="s2">&quot;digraph&quot;</span> <span class="s2">&quot; -&gt; &quot;</span>
      <span class="n">string_of_int</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span><span class="o">)</span> <span class="n">g</span> <span class="k">in</span>
  <span class="n">write_string_to_file</span> <span class="n">out</span> <span class="n">s</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">graphviz_string_of_graph</span></code> takes many arguments:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">``</span><span class="n">gtyp</span><span class="o">``</span> <span class="n">is</span> <span class="n">the</span> <span class="k">type</span> <span class="k">of</span> <span class="n">the</span> <span class="n">graph</span> <span class="k">to</span> <span class="n">be</span> <span class="n">renderred</span> <span class="o">(</span><span class="n">directed</span><span class="o">/</span><span class="n">undirected</span><span class="o">);</span>
<span class="o">*</span> <span class="o">``</span><span class="n">conn</span><span class="o">``</span> <span class="n">is</span> <span class="n">a</span> <span class="n">connective</span> <span class="n">determining</span> <span class="n">the</span> <span class="n">shape</span> <span class="k">of</span> <span class="n">edges</span><span class="o">;</span>
<span class="o">*</span> <span class="o">``</span><span class="n">vattrib</span><span class="o">``</span> <span class="n">is</span> <span class="n">a</span> <span class="k">function</span> <span class="k">to</span> <span class="n">render</span> <span class="n">nodes</span><span class="o">;</span>
<span class="o">*</span> <span class="o">``</span><span class="n">eattrib</span><span class="o">``</span> <span class="n">is</span> <span class="n">a</span> <span class="k">function</span> <span class="k">to</span> <span class="n">render</span> <span class="n">edges</span><span class="o">;</span>
<span class="o">*</span> <span class="o">``</span><span class="n">g</span><span class="o">``</span> <span class="n">is</span> <span class="n">a</span> <span class="n">graph</span> <span class="n">itself</span> <span class="k">in</span> <span class="n">an</span> <span class="n">adjacency</span><span class="o">-</span><span class="kt">list</span> <span class="n">representation</span>
</pre></div>
</div>
<p>When run <code class="docutils literal notranslate"><span class="pre">graphviz_no_payload</span> <span class="pre">g</span> <span class="pre">&quot;graph.dot&quot;</span></code> produces a file named <code class="docutils literal notranslate"><span class="pre">graph.dot</span></code>, which can be then renderred from the console via GraphViz-provided utility <code class="docutils literal notranslate"><span class="pre">dot</span></code> as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">dot</span> <span class="o">-</span><span class="nc">Tpdf</span> <span class="n">filename</span><span class="o">.</span><span class="n">dot</span> <span class="o">-</span><span class="n">o</span> <span class="n">outfile</span><span class="o">.</span><span class="n">pdf</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">filename.dot</span></code> can be any GraphViz-formatted file (can be also named differently), and <code class="docutils literal notranslate"><span class="pre">outfile.pdf</span></code> is the resulting PDF file with the graph.</p>
<p>The image above has been obtained via GraphViz for the graph, read from <code class="docutils literal notranslate"><span class="pre">small_graph_shape</span></code>.</p>
</div>
<div class="section" id="shortcomings-of-adjacency-list-graph-representation">
<h2>12.2.4. Shortcomings of Adjacency-List graph representation<a class="headerlink" href="#shortcomings-of-adjacency-list-graph-representation" title="Permalink to this headline">¶</a></h2>
<p>The main disadvantage of adjacency-list based representation is that the operations of adding an edge, getting successors (and possibly predecessors) of a node in it are very expensive.</p>
</div>
<div class="section" id="graphs-as-linked-data-structures">
<h2>12.2.5. Graphs as Linked Data Structures<a class="headerlink" href="#graphs-as-linked-data-structures" title="Permalink to this headline">¶</a></h2>
<p>Let us consider a more efficient implementation of graphs as linked data structure. The implementation imposes some overhead, in order to provide an efficient access to the nodes of a graph as well as their adjacent neighbours. The implementation will rely on data structures developed previously: hash-tables and sets, represented via BSTs.</p>
<p>We start by defining the data type for nodes:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">LinkedGraphs</span> <span class="o">=</span> <span class="k">struct</span>

  <span class="c">(*************************************************)</span>
  <span class="c">(*                     Nodes                     *)</span>
  <span class="c">(*************************************************)</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">node</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">id</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
    <span class="k">value</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">ref</span><span class="o">;</span>
    <span class="n">next</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="n">ref</span><span class="o">;</span>
    <span class="n">prev</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="n">ref</span>
  <span class="o">}</span>

  <span class="k">let</span> <span class="n">get_value</span> <span class="n">n</span> <span class="o">=</span> <span class="o">!(</span><span class="n">n</span><span class="o">.</span><span class="k">value</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">get_next</span> <span class="n">n</span> <span class="o">=</span> <span class="o">!(</span><span class="n">n</span><span class="o">.</span><span class="n">next</span><span class="o">)</span>
  <span class="k">let</span> <span class="n">get_prev</span> <span class="n">n</span> <span class="o">=</span> <span class="o">!(</span><span class="n">n</span><span class="o">.</span><span class="n">prev</span><span class="o">)</span>

  <span class="k">let</span> <span class="n">add_prev</span> <span class="n">node</span> <span class="n">src</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">prev&#39;</span> <span class="o">=</span> <span class="n">get_prev</span> <span class="n">node</span> <span class="o">|&gt;</span>
                <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">src</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">node</span><span class="o">.</span><span class="n">prev</span> <span class="o">:=</span> <span class="n">src</span> <span class="o">::</span> <span class="n">prev&#39;</span>

  <span class="k">let</span> <span class="n">add_next</span> <span class="n">node</span> <span class="n">dst</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">next&#39;</span> <span class="o">=</span> <span class="n">get_next</span> <span class="n">node</span> <span class="o">|&gt;</span>
                <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">node</span><span class="o">.</span><span class="n">next</span> <span class="o">:=</span> <span class="n">dst</span> <span class="o">::</span> <span class="n">next&#39;</span>

  <span class="c">(* More types and functions are coming here *)</span>

<span class="k">end</span>
</pre></div>
</div>
<p>Each node stores its identifier (an integer), a payload <code class="docutils literal notranslate"><span class="pre">value</span></code>, as well as lists of “previous” and “next” nodes in the graph (initially empty).</p>
<p>We now defing a graph as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(*************************************************)</span>
<span class="c">(*           Auxiliary definitions               *)</span>
<span class="c">(*************************************************)</span>

<span class="k">open</span> <span class="nc">Week_12_BST</span>
<span class="k">open</span> <span class="nc">Week_08_HashTable</span>

<span class="k">module</span> <span class="nc">Set</span> <span class="o">=</span> <span class="nc">BinarySearchTree</span>
<span class="k">module</span> <span class="nc">NodeTable</span> <span class="o">=</span>
  <span class="nc">ResizableListBasedHashTable</span><span class="o">(</span><span class="k">struct</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span> <span class="k">end</span><span class="o">)</span>
<span class="k">module</span> <span class="nc">EdgeTable</span> <span class="o">=</span>
  <span class="nc">ResizableListBasedHashTable</span><span class="o">(</span><span class="k">struct</span> <span class="k">type</span> <span class="n">t</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span> <span class="k">end</span><span class="o">)</span>

<span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">set</span> <span class="o">=</span> <span class="k">&#39;</span><span class="n">a</span> <span class="nn">Set</span><span class="p">.</span><span class="n">tree</span>

<span class="c">(*************************************************)</span>
<span class="c">(*                Working with Graphs            *)</span>
<span class="c">(*************************************************)</span>

<span class="k">type</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">next_node_id</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span><span class="o">;</span>
  <span class="n">nodes</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">set</span><span class="o">;</span>
  <span class="n">node_map</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">node</span><span class="o">)</span> <span class="nn">NodeTable</span><span class="p">.</span><span class="n">hash_table</span><span class="o">;</span>

  <span class="n">edges</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="n">set</span><span class="o">;</span>
  <span class="n">edge_labels</span> <span class="o">:</span> <span class="o">((</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="nn">EdgeTable</span><span class="p">.</span><span class="n">hash_table</span>
<span class="o">}</span>
</pre></div>
</div>
<p>That is, a graph contains:</p>
<ul class="simple">
<li>a counter <code class="docutils literal notranslate"><span class="pre">next_node_id</span></code> used to allocate identifiers for newly added nodes;</li>
<li>a set (represented via BST) <code class="docutils literal notranslate"><span class="pre">nodes</span></code> of all node identifies;</li>
<li><code class="docutils literal notranslate"><span class="pre">node_map</span></code> for mapping node identifiers to node objects;</li>
<li>a set of edges (<code class="docutils literal notranslate"><span class="pre">edges</span></code>);</li>
<li>a hash map of edge labels (<code class="docutils literal notranslate"><span class="pre">edge_labels</span></code>).</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">graph</span></code> structure defined just above allows to access the set of predecessors/successors of a node in a constant time, as opposed to linear one with the list-based representation. Consider the following utility functions:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(* Graph size *)</span>
<span class="k">let</span> <span class="n">v_size</span> <span class="n">g</span> <span class="o">=</span> <span class="o">!(</span><span class="n">g</span><span class="o">.</span><span class="n">next_node_id</span><span class="o">)</span>
<span class="k">let</span> <span class="n">e_size</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">BinarySearchTree</span><span class="p">.</span><span class="n">get_size</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span>
<span class="k">let</span> <span class="n">get_nodes</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="n">elements</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span>

<span class="c">(* Refer to the node in the graph *)</span>
<span class="k">let</span> <span class="n">get_node</span> <span class="n">g</span> <span class="n">i</span> <span class="o">=</span> <span class="nn">Week_01</span><span class="p">.</span><span class="n">get_exn</span> <span class="o">@@</span> <span class="nn">NodeTable</span><span class="p">.</span><span class="n">get</span> <span class="n">g</span><span class="o">.</span><span class="n">node_map</span> <span class="n">i</span>

<span class="k">let</span> <span class="n">get_succ</span> <span class="n">g</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_node</span> <span class="n">g</span> <span class="n">n</span> <span class="k">in</span>
  <span class="n">get_next</span> <span class="n">node</span>

<span class="k">let</span> <span class="n">get_prev</span> <span class="n">g</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="n">get_node</span> <span class="n">g</span> <span class="n">n</span> <span class="k">in</span>
  <span class="n">get_prev</span> <span class="n">node</span>

<span class="k">let</span> <span class="n">node_in_graph</span> <span class="n">g</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span> <span class="k">in</span>
  <span class="nn">Set</span><span class="p">.</span><span class="n">search</span> <span class="n">nodes</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>

<span class="k">let</span> <span class="n">edge_in_graph</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span> <span class="k">in</span>
  <span class="nn">Set</span><span class="p">.</span><span class="n">search</span> <span class="n">nodes</span> <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">)</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>As the linked <code class="docutils literal notranslate"><span class="pre">graph</span></code> structure combines five conceptually “overlapping” components, it needs to be maintaned with a lot of care, in order not to introduce any discrepancies in the representations.</p>
<p>Creating new linked graph is easy:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">mk_graph</span> <span class="o">_</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">next_node_id</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">;</span>
  <span class="n">nodes</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="n">mk_tree</span> <span class="bp">()</span><span class="o">;</span>
  <span class="n">node_map</span> <span class="o">=</span> <span class="nn">NodeTable</span><span class="p">.</span><span class="n">mk_new_table</span> <span class="mi">10</span><span class="o">;</span>
  <span class="n">edges</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="n">mk_tree</span> <span class="bp">()</span><span class="o">;</span>
  <span class="n">edge_labels</span> <span class="o">=</span> <span class="nn">EdgeTable</span><span class="p">.</span><span class="n">mk_new_table</span> <span class="mi">10</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Adding a node requires allocating it a new id, registering it in both the set of node identifiers, and the node map:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add_node</span> <span class="n">g</span> <span class="n">v</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">new_id</span> <span class="o">=</span> <span class="o">!(</span><span class="n">g</span><span class="o">.</span><span class="n">next_node_id</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">g</span><span class="o">.</span><span class="n">next_node_id</span> <span class="o">:=</span> <span class="o">!(</span><span class="n">g</span><span class="o">.</span><span class="n">next_node_id</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">id</span> <span class="o">=</span> <span class="n">new_id</span><span class="o">;</span>
    <span class="k">value</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">v</span><span class="o">;</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span><span class="o">;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span><span class="o">;</span>
  <span class="o">}</span> <span class="k">in</span>
  <span class="c">(* Register node *)</span>
  <span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="n">insert</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span> <span class="n">new_id</span> <span class="k">in</span>
  <span class="c">(* Register node payload *)</span>
  <span class="nn">NodeTable</span><span class="p">.</span><span class="n">insert</span> <span class="n">g</span><span class="o">.</span><span class="n">node_map</span> <span class="n">new_id</span> <span class="n">node</span>
</pre></div>
</div>
<p>Adding an edge requires modifying the corresponding node instances to account for new predecessors and successors:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add_edge</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Week_01</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">node_in_graph</span> <span class="n">g</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">node_in_graph</span> <span class="n">g</span> <span class="n">src</span><span class="o">);</span>
  <span class="c">(* Register edge *)</span>
  <span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="n">insert</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span> <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">)</span> <span class="k">in</span>
  <span class="c">(* Add information to individual nodes *)</span>
  <span class="k">let</span> <span class="n">src_node</span> <span class="o">=</span> <span class="n">get_exn</span> <span class="o">@@</span> <span class="nn">NodeTable</span><span class="p">.</span><span class="n">get</span> <span class="n">g</span><span class="o">.</span><span class="n">node_map</span> <span class="n">src</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">dst_node</span> <span class="o">=</span> <span class="n">get_exn</span> <span class="o">@@</span> <span class="nn">NodeTable</span><span class="p">.</span><span class="n">get</span> <span class="n">g</span><span class="o">.</span><span class="n">node_map</span> <span class="n">dst</span> <span class="k">in</span>
  <span class="n">add_prev</span> <span class="n">dst_node</span> <span class="n">src</span><span class="o">;</span>
  <span class="n">add_next</span> <span class="n">src_node</span> <span class="n">dst</span>
</pre></div>
</div>
<p>We can also set a new label to an edge <code class="docutils literal notranslate"><span class="pre">(src,</span> <span class="pre">dst)</span></code> as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">set_edge_label</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">Week_01</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">node_in_graph</span> <span class="n">g</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">node_in_graph</span> <span class="n">g</span> <span class="n">src</span><span class="o">);</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">edge_in_graph</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span><span class="o">);</span>
  <span class="c">(* Register label *)</span>
  <span class="nn">EdgeTable</span><span class="p">.</span><span class="n">insert</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_labels</span> <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">)</span> <span class="n">l</span>
</pre></div>
</div>
</div>
<div class="section" id="switching-between-graph-representations">
<h2>12.2.6. Switching between graph representations<a class="headerlink" href="#switching-between-graph-representations" title="Permalink to this headline">¶</a></h2>
<p>As we already have reading/writing implemented for AL-based graphs, let us implement conversion between them and linked representations. The following function, for instance, converts a simple AL-based graph (with arbitrary node payloads) to a linked representation:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">from_simple_adjacency_graph</span> <span class="o">(</span><span class="n">ag</span> <span class="o">:</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">graph</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">g</span> <span class="o">=</span> <span class="n">mk_graph</span> <span class="bp">()</span> <span class="k">in</span>

  <span class="c">(* Add nodes *)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">ag</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">snd</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">find</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="o">)</span> <span class="o">!(</span><span class="n">ag</span><span class="o">.</span><span class="n">node_payloads</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">add_node</span> <span class="n">g</span> <span class="n">v</span><span class="o">;</span>
  <span class="k">done</span><span class="o">;</span>

  <span class="c">(* Add edges *)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">ag</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">ag</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">|&gt;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="o">|&gt;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">add_edge</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span><span class="o">)</span>
  <span class="k">done</span><span class="o">;</span>

  <span class="c">(* Add edge labels *)</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">((</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">),</span> <span class="n">l</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">set_edge_label</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="n">l</span><span class="o">)</span>
    <span class="o">!(</span><span class="n">ag</span><span class="o">.</span><span class="n">edge_labels</span><span class="o">);</span>

  <span class="n">g</span>
</pre></div>
</div>
<p>Conversely, the following functions obtains an adjacency graph from a linked representation:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">to_adjacency_graph</span> <span class="n">g</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="n">v_size</span> <span class="n">g</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ag</span> <span class="o">=</span> <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">mk_graph</span> <span class="n">size</span> <span class="k">in</span>

  <span class="c">(* Set node payloads *)</span>
  <span class="nn">Set</span><span class="p">.</span><span class="n">elements</span> <span class="n">g</span><span class="o">.</span><span class="n">nodes</span> <span class="o">|&gt;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="nn">Week_01</span><span class="p">.</span><span class="n">get_exn</span> <span class="o">@@</span> <span class="nn">NodeTable</span><span class="p">.</span><span class="n">get</span> <span class="n">g</span><span class="o">.</span><span class="n">node_map</span> <span class="n">n</span> <span class="k">in</span>
      <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">set_payload</span> <span class="n">ag</span> <span class="n">n</span> <span class="o">(</span><span class="n">get_value</span> <span class="n">node</span><span class="o">));</span>

  <span class="c">(* Add edges *)</span>
  <span class="k">let</span> <span class="n">edges</span> <span class="o">=</span> <span class="nn">Set</span><span class="p">.</span><span class="n">elements</span> <span class="n">g</span><span class="o">.</span><span class="n">edges</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">add_edge</span> <span class="n">ag</span> <span class="n">src</span> <span class="n">dst</span><span class="o">)</span> <span class="n">edges</span><span class="o">;</span>

  <span class="c">(* Add edges labels *)</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="k">match</span> <span class="nn">EdgeTable</span><span class="p">.</span><span class="n">get</span> <span class="n">g</span><span class="o">.</span><span class="n">edge_labels</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">set_edge_label</span> <span class="n">ag</span> <span class="n">s</span> <span class="n">d</span> <span class="n">l</span><span class="o">)</span> <span class="n">edges</span><span class="o">;</span>
  <span class="n">ag</span>
</pre></div>
</div>
<p>We can now put those functions to use for getting linked graphs immediate from the strings and files:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">parse_linked_int_graph</span> <span class="n">ls</span> <span class="o">=</span>
  <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">adjacency_int_graph_of_strings</span> <span class="n">ls</span> <span class="o">|&gt;</span>
  <span class="n">from_simple_adjacency_graph</span>

<span class="k">let</span> <span class="n">read_simple_linked_graph_from_file</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">ag</span> <span class="o">=</span> <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">read_simple_graph_shape_from_file</span> <span class="n">filename</span> <span class="k">in</span>
  <span class="n">from_simple_adjacency_graph</span> <span class="n">ag</span>
</pre></div>
</div>
</div>
<div class="section" id="testing-graph-operations">
<h2>12.2.7. Testing graph operations<a class="headerlink" href="#testing-graph-operations" title="Permalink to this headline">¶</a></h2>
<p>One advantage of AL-based representation is that it makes it considerably easier to test graphs for certain properties. For instance, the following function checks that two AL-represented graphs have the same topology (i.e., the same sets of node identifiers, and edges between them):</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">same_shape</span> <span class="o">(</span><span class="n">ag1</span> <span class="o">:</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">graph</span><span class="o">)</span>
    <span class="o">(</span><span class="n">ag2</span> <span class="o">:</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">graph</span><span class="o">)</span> <span class="o">=</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">ag1</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">ag2</span><span class="o">.</span><span class="n">size</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">ag1</span><span class="o">.</span><span class="n">size</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">comp</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>
    <span class="k">then</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>
    <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">adj1</span> <span class="o">=</span> <span class="n">ag1</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">comp</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">adj2</span> <span class="o">=</span> <span class="n">ag1</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">sort</span> <span class="n">comp</span> <span class="k">in</span>
    <span class="k">assert</span> <span class="o">(</span><span class="n">adj1</span> <span class="o">=</span> <span class="n">adj2</span><span class="o">)</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="bp">true</span>
</pre></div>
</div>
<p>We can use it to check that out AL-to-linked-and-back conversion preserves the graph shape. Take the following graph:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">medium_graph_shape</span> <span class="o">=</span>
  <span class="o">[</span><span class="s2">&quot;13&quot;</span><span class="o">;</span>
   <span class="s2">&quot;0 1&quot;</span><span class="o">;</span>
   <span class="s2">&quot;0 6&quot;</span><span class="o">;</span>
   <span class="s2">&quot;0 5&quot;</span><span class="o">;</span>
   <span class="s2">&quot;2 0&quot;</span><span class="o">;</span>
   <span class="s2">&quot;2 3&quot;</span><span class="o">;</span>
   <span class="s2">&quot;3 5&quot;</span><span class="o">;</span>
   <span class="s2">&quot;5 4&quot;</span><span class="o">;</span>
   <span class="s2">&quot;6 4&quot;</span><span class="o">;</span>
   <span class="s2">&quot;7 6&quot;</span><span class="o">;</span>
   <span class="s2">&quot;8 7&quot;</span><span class="o">;</span>
   <span class="s2">&quot;6 9&quot;</span><span class="o">;</span>
   <span class="s2">&quot;9 10&quot;</span><span class="o">;</span>
   <span class="s2">&quot;9 11&quot;</span><span class="o">;</span>
   <span class="s2">&quot;9 12&quot;</span><span class="o">;</span>
   <span class="s2">&quot;11 12&quot;</span><span class="o">]</span>
</pre></div>
</div>
<p>We can now make sure that the following test succeeds:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span><span class="o">%</span><span class="n">test</span> <span class="o">_</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">ag</span> <span class="o">=</span> <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">adjacency_int_graph_of_strings</span> <span class="n">medium_graph_shape</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">LinkedGraphs</span><span class="p">.</span><span class="n">from_simple_adjacency_graph</span> <span class="n">ag</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ag&#39;</span> <span class="o">=</span> <span class="nn">LinkedGraphs</span><span class="p">.</span><span class="n">to_adjacency_graph</span> <span class="n">g</span> <span class="k">in</span>
  <span class="n">same_shape</span> <span class="n">ag</span> <span class="n">ag&#39;</span>
</pre></div>
</div>
<p>We can also try out the conversion machinery for the sake of producing nice GraphViz images:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">utop</span> <span class="o">#</span> <span class="k">let</span> <span class="n">g</span> <span class="o">=</span> <span class="nn">LinkedGraphs</span><span class="p">.</span><span class="n">parse_linked_int_graph</span> <span class="n">medium_graph_shape</span><span class="o">;;</span>
<span class="n">utop</span> <span class="o">#</span> <span class="k">let</span> <span class="n">ag</span> <span class="o">=</span> <span class="nn">LinkedGraphs</span><span class="p">.</span><span class="n">to_adjacency_graph</span> <span class="n">g</span><span class="o">;;</span>
<span class="n">utop</span> <span class="o">#</span> <span class="n">graphviz_no_payload</span> <span class="n">ag</span> <span class="s2">&quot;medium.dot&quot;</span><span class="o">;;</span>
</pre></div>
</div>
<p>No, running:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">dot</span> <span class="o">-</span><span class="nc">Tpdf</span> <span class="n">medium</span><span class="o">.</span><span class="n">dot</span> <span class="o">-</span><span class="n">o</span> <span class="n">medium</span><span class="o">.</span><span class="n">pdf</span>
</pre></div>
</div>
<p>we obtain the following image:</p>
<a class="reference internal image-reference" href="_images/medium.png"><img alt="_images/medium.png" class="align-center" src="_images/medium.png" style="width: 500px;" /></a>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="week-12_exercises.html" class="btn btn-neutral float-right" title="12.3. Exercises" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="week-12_bst.html" class="btn btn-neutral" title="12.1. Representing Sets via Binary Search Trees" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Ilya Sergey

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"]})</script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>