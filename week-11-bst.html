

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>12.1. Representing Sets via Binary Search Trees &mdash; YSC2229 2021</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="12.2. Representing Graphs" href="week-11-graphs.html" />
    <link rel="prev" title="12. Week 11: Binary Search Trees and Graphs" href="week-11.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> YSC2229: Introductory Data Structures and Algorithms
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="syllabus.html">1. Course Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="prerequisites.html">2. Software Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="codestyle.html">3. OCaml Style Guide</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="week-01.html">1. Week 01: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-02.html">2. Week 02: Working with Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-03.html">3. Week 03: Complexity of Algorithms and Order Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-04.html">4. Week 04: Divide-and-Conquer Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-05.html">5. Week 05: Binary Heaps and Priority Queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-06.html">6. Week 06: Abstract Data Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="midterm.html">7. Midterm Project: Memory Allocation and Reclamation</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-07.html">8. Week 07: Hashing-Based Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-08.html">9. Week 08: Searching in Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-09.html">10. Week 09: Backtracking and Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-10.html">11. Week 10: Data Encoding and Compression</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="week-11.html">12. Week 11: Binary Search Trees and Graphs</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">12.1. Representing Sets via Binary Search Trees</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-data-structure-for-binary-search-trees">12.1.1. A Data Structure for Binary-Search Trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inserting-an-element-into-a-bst">12.1.2. Inserting an element into a BST</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binary-search-tree-invariant">12.1.3. Binary-Search-Tree Invariant</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-tree-operations">12.1.4. Testing Tree Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#printing-a-tree">12.1.5. Printing a Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#searching-elements">12.1.6. Searching Elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tree-traversals">12.1.7. Tree Traversals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-element-retrieval-and-tree-traversals">12.1.8. Testing Element Retrieval and Tree Traversals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#more-bst-operations">12.1.9. More BST operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deleting-a-node-from-bst">12.1.10. Deleting a node from BST</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bst-rotations">12.1.11. BST Rotations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week-11-graphs.html">12.2. Representing Graphs</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">YSC2229: Introductory Data Structures and Algorithms</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="week-11.html">12. Week 11: Binary Search Trees and Graphs</a> &raquo;</li>
        
      <li>12.1. Representing Sets via Binary Search Trees</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="representing-sets-via-binary-search-trees">
<span id="bst"></span><h1>12.1. Representing Sets via Binary Search Trees<a class="headerlink" href="#representing-sets-via-binary-search-trees" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>File <code class="docutils literal notranslate"><span class="pre">BST.ml</span></code></li>
</ul>
<p>Binary Search Trees (BSTs) are one of the most versatile
representations of mutable sets of <cite>ordered elements</cite>, supporting a
variety of operations, such as insertion, deletion, checking
membership, finding minimums, maximums, predecessors and successors of
a value — all those operations taking the time proportional to the
height <span class="math notranslate nohighlight">\(h\)</span> of the tree or, if the tree is constructed randomly
out of <span class="math notranslate nohighlight">\(n\)</span> elements — <span class="math notranslate nohighlight">\(O(\log n)\)</span>. This makes BST a
superior alternative to lists, heaps, and even hash-tables when
impelmenting mutable sets with a number of standard set operations.</p>
<p>The key to this expressivity and efficience is the invariant of a
tree-shaped data structure, that mandates that, for any node <code class="docutils literal notranslate"><span class="pre">q</span></code>,</p>
<ul class="simple">
<li>any element in its left subtree <code class="docutils literal notranslate"><span class="pre">q.l</span></code> is less or equal (with
respect to a certain total order) than the element in the node <code class="docutils literal notranslate"><span class="pre">q</span></code>
itself, and</li>
<li>any element in its right subtree <code class="docutils literal notranslate"><span class="pre">q.r</span></code> is greater or equal than
the element in the node <code class="docutils literal notranslate"><span class="pre">q</span></code> itself.</li>
</ul>
<p>This invariant is maintained by all operations that modify the set,
and is relied upon by all its queries. The logarithmic complexity of
operations, thus, follows from the intuition similar to the one
powering <a class="reference internal" href="week-03-search.html#binsearch"><span class="std std-ref">Binary Search</span></a> in arrays.</p>
<div class="section" id="a-data-structure-for-binary-search-trees">
<h2>12.1.1. A Data Structure for Binary-Search Trees<a class="headerlink" href="#a-data-structure-for-binary-search-trees" title="Permalink to this headline">¶</a></h2>
<p>We start by defining a linked in-memory data structure for BSTs in its own module.</p>
<p>The tree is populated by nodes, each of which carries a value
(immutable), and also maintains references (mutable) to its left/right
children and a parent, which can be either absent or refer to some
other nodes of the tree:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">BinarySearchTree</span> <span class="o">=</span> <span class="k">struct</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">e</span> <span class="n">tree_node</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">value</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">e</span><span class="o">;</span>
    <span class="n">parent</span>  <span class="o">:</span> <span class="k">&#39;</span><span class="n">e</span> <span class="n">tree_node</span> <span class="n">option</span> <span class="n">ref</span><span class="o">;</span>
    <span class="n">left</span>  <span class="o">:</span> <span class="k">&#39;</span><span class="n">e</span> <span class="n">tree_node</span> <span class="n">option</span> <span class="n">ref</span><span class="o">;</span>
    <span class="n">right</span>  <span class="o">:</span> <span class="k">&#39;</span><span class="n">e</span> <span class="n">tree_node</span> <span class="n">option</span> <span class="n">ref</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="k">type</span> <span class="k">&#39;</span><span class="n">e</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">root</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">e</span> <span class="n">tree_node</span> <span class="n">option</span> <span class="n">ref</span><span class="o">;</span>
    <span class="n">size</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">ref</span>
  <span class="o">}</span>

  <span class="c">(* More definitions coming here *)</span>

<span class="k">end</span>
</pre></div>
</div>
<p>For convenience, we define several operations to dereference various components of a tree and its nodes:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">left</span> <span class="n">n</span> <span class="o">=</span> <span class="o">!(</span><span class="n">n</span><span class="o">.</span><span class="n">left</span><span class="o">)</span>
<span class="k">let</span> <span class="n">right</span> <span class="n">n</span> <span class="o">=</span> <span class="o">!(</span><span class="n">n</span><span class="o">.</span><span class="n">right</span><span class="o">)</span>
<span class="k">let</span> <span class="n">parent</span> <span class="n">n</span> <span class="o">=</span> <span class="o">!(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">)</span>
<span class="k">let</span> <span class="n">get_root</span> <span class="n">t</span> <span class="o">=</span> <span class="o">!(</span><span class="n">t</span><span class="o">.</span><span class="n">root</span><span class="o">)</span>
<span class="k">let</span> <span class="n">get_size</span> <span class="n">t</span> <span class="o">=</span> <span class="o">!(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>

<span class="k">let</span> <span class="n">mk_node</span> <span class="n">e</span> <span class="o">=</span>
  <span class="o">{</span><span class="k">value</span> <span class="o">=</span> <span class="n">e</span><span class="o">;</span>
   <span class="n">parent</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span><span class="o">;</span>
   <span class="n">left</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span><span class="o">;</span>
   <span class="n">right</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span><span class="o">}</span>

<span class="k">let</span> <span class="n">mk_tree</span> <span class="o">_</span> <span class="o">=</span> <span class="o">{</span><span class="n">root</span> <span class="o">=</span> <span class="n">ref</span> <span class="nc">None</span><span class="o">;</span> <span class="n">size</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span><span class="o">}</span>
</pre></div>
</div>
<p>Finally, since nodes are represented by an <code class="docutils literal notranslate"><span class="pre">option</span></code> type, we introduce the following combinator, simplifying working with <code class="docutils literal notranslate"><span class="pre">option</span></code>-wrapped values:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">map_option</span> <span class="n">o</span> <span class="n">f</span> <span class="n">z</span> <span class="o">=</span> <span class="k">match</span> <span class="n">o</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">z</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">n</span>
</pre></div>
</div>
<p>In words <code class="docutils literal notranslate"><span class="pre">map_option</span></code> returns applies <code class="docutils literal notranslate"><span class="pre">f</span></code> to the value <code class="docutils literal notranslate"><span class="pre">n</span></code> within <code class="docutils literal notranslate"><span class="pre">o</span></code>, if <code class="docutils literal notranslate"><span class="pre">o</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">n</span></code>, or returns <code class="docutils literal notranslate"><span class="pre">z</span></code> otherwise.</p>
</div>
<div class="section" id="inserting-an-element-into-a-bst">
<h2>12.1.2. Inserting an element into a BST<a class="headerlink" href="#inserting-an-element-into-a-bst" title="Permalink to this headline">¶</a></h2>
<p>The defined above <code class="docutils literal notranslate"><span class="pre">mk_tree</span></code> function creates an empty tree. Let us now implement a procedure for populating it with elements by inserting them one by one:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">insert</span> <span class="n">t</span> <span class="n">e</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">insert_element</span> <span class="n">n</span> <span class="n">e</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mk_node</span> <span class="n">e</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">.</span><span class="k">value</span>
    <span class="k">then</span> <span class="k">match</span> <span class="n">left</span> <span class="n">n</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">insert_element</span> <span class="n">m</span> <span class="n">e</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
        <span class="n">m</span><span class="o">.</span><span class="n">parent</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">n</span><span class="o">.</span><span class="n">left</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">m</span><span class="o">;</span>
        <span class="bp">true</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="n">n</span><span class="o">.</span><span class="k">value</span>
    <span class="k">then</span> <span class="k">match</span> <span class="n">right</span> <span class="n">n</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">insert_element</span> <span class="n">m</span> <span class="n">e</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span>
        <span class="n">m</span><span class="o">.</span><span class="n">parent</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">n</span><span class="o">;</span>
        <span class="n">n</span><span class="o">.</span><span class="n">right</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">m</span><span class="o">;</span>
        <span class="bp">true</span>
    <span class="k">else</span> <span class="bp">false</span>
  <span class="k">in</span>
  <span class="k">match</span> <span class="o">!(</span><span class="n">t</span><span class="o">.</span><span class="n">root</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="o">(</span>
      <span class="n">t</span><span class="o">.</span><span class="n">root</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">mk_node</span> <span class="n">e</span><span class="o">);</span>
      <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">;</span>
      <span class="bp">true</span><span class="o">)</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">n</span> <span class="o">-&gt;</span>
    <span class="k">if</span> <span class="n">insert_element</span> <span class="n">n</span> <span class="n">e</span>
    <span class="k">then</span> <span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">:=</span> <span class="o">!(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="bp">true</span><span class="o">)</span>
    <span class="k">else</span> <span class="bp">false</span>
</pre></div>
</div>
<p>Notice that the main working routine <code class="docutils literal notranslate"><span class="pre">insert_element</span></code> respects the
BST property defined above: it positions the node <code class="docutils literal notranslate"><span class="pre">m</span></code> with the
element <code class="docutils literal notranslate"><span class="pre">e</span></code>, so it would be in the correct subtree
(smaller-left/greater-right) with respect to its parent nodes.
Finally, <code class="docutils literal notranslate"><span class="pre">insert_element</span></code> returns a boolean to indicate whether the
element has been indeed added (<code class="docutils literal notranslate"><span class="pre">true</span></code>) or ignored as duplicated
(<code class="docutils literal notranslate"><span class="pre">false</span></code>). In the former case the size of the tree is increased, in
the latter it remains the same.</p>
</div>
<div class="section" id="binary-search-tree-invariant">
<h2>12.1.3. Binary-Search-Tree Invariant<a class="headerlink" href="#binary-search-tree-invariant" title="Permalink to this headline">¶</a></h2>
<p>Let us now assert that tree-manipulating operations such as <code class="docutils literal notranslate"><span class="pre">insert</span></code>
indeed preserve the discussed above BST property. For this, let us
define the BST invariant in the form of the following function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">check_bst_inv</span> <span class="n">t</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">walk</span> <span class="n">node</span> <span class="n">p</span> <span class="o">=</span>
    <span class="o">(</span><span class="n">p</span> <span class="n">node</span><span class="o">.</span><span class="k">value</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
    <span class="k">let</span> <span class="n">res_left</span> <span class="o">=</span> <span class="k">match</span> <span class="n">left</span> <span class="n">node</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">true</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">walk</span> <span class="n">l</span> <span class="o">(</span><span class="k">fun</span> <span class="n">w</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="n">node</span><span class="o">.</span><span class="k">value</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="k">let</span> <span class="n">res_right</span> <span class="o">=</span> <span class="k">match</span> <span class="n">right</span> <span class="n">node</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">true</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">walk</span> <span class="n">r</span> <span class="o">(</span><span class="k">fun</span> <span class="n">w</span> <span class="o">-&gt;</span> <span class="n">p</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">w</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="o">.</span><span class="k">value</span><span class="o">)</span>
    <span class="k">in</span>
    <span class="n">res_left</span> <span class="o">&amp;&amp;</span> <span class="n">res_right</span>
  <span class="k">in</span>
  <span class="k">match</span> <span class="o">!(</span><span class="n">t</span><span class="o">.</span><span class="n">root</span><span class="o">)</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">true</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">walk</span> <span class="n">n</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">true</span><span class="o">)</span>
</pre></div>
</div>
<p>The main recursive sub-function <code class="docutils literal notranslate"><span class="pre">walk</span></code> works by “growing” a predicate <code class="docutils literal notranslate"><span class="pre">p</span></code> that applies to each node further down the tree, making sure that it is correctly positioned with regard to all its parents. At the top level <code class="docutils literal notranslate"><span class="pre">p</span></code> is instantiated with <code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">_</span> <span class="pre">-&gt;</span> <span class="pre">true)</span></code>, as there are no restrictions imposed for the root of the tree, but more and more conjuncts added, as the checking proceeds recursively.</p>
</div>
<div class="section" id="testing-tree-operations">
<h2>12.1.4. Testing Tree Operations<a class="headerlink" href="#testing-tree-operations" title="Permalink to this headline">¶</a></h2>
<p>Let us put or invariant to work by using it to test the correctness of <code class="docutils literal notranslate"><span class="pre">insert</span></code>.</p>
<p>We do so by first defining a function for generating random trees from random arrays via insertion:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">BinarySearchTree</span>

<span class="k">let</span> <span class="n">mk_tree_of_size</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mk_tree</span> <span class="bp">()</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">generate_key_value_array</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">insert</span> <span class="n">t</span> <span class="n">a</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="n">t</span>
</pre></div>
</div>
<p>Next, we check that the generated trees indeed satisfy the BST property:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span><span class="o">%</span><span class="n">test</span> <span class="s2">&quot;Testing insertion&quot;</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mk_tree_of_size</span> <span class="n">n</span> <span class="k">in</span>
  <span class="n">check_bst_inv</span> <span class="n">t</span>
</pre></div>
</div>
</div>
<div class="section" id="printing-a-tree">
<h2>12.1.5. Printing a Tree<a class="headerlink" href="#printing-a-tree" title="Permalink to this headline">¶</a></h2>
<p>It would be very nice if we could not only test but also visualise our binary search trees.</p>
<p>Unfortunately, printing a tree in a standard top-down fashion requires
quite a bit of book-keeping of tree-specific information. Printing a
tree left-to-right is, however, can be done quite easily as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">print_tree</span> <span class="n">pp</span> <span class="n">snum</span> <span class="n">t</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">print_node_with_spaces</span> <span class="n">l</span> <span class="n">s</span> <span class="o">=</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">s</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot; &quot;</span>
    <span class="k">done</span><span class="o">;</span>
    <span class="n">print_endline</span> <span class="o">(</span><span class="n">pp</span> <span class="n">l</span><span class="o">.</span><span class="k">value</span><span class="o">);</span>
  <span class="k">in</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">walk</span> <span class="n">s</span> <span class="n">node</span> <span class="o">=</span> <span class="k">match</span> <span class="n">node</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="k">begin</span>
        <span class="n">walk</span> <span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">snum</span><span class="o">)</span> <span class="o">(</span><span class="n">right</span> <span class="n">n</span><span class="o">);</span>
        <span class="n">print_node_with_spaces</span> <span class="n">n</span> <span class="n">s</span><span class="o">;</span>
        <span class="n">walk</span> <span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="n">snum</span><span class="o">)</span> <span class="o">(</span><span class="n">left</span> <span class="n">n</span><span class="o">);</span>
      <span class="k">end</span>

  <span class="k">in</span>
  <span class="n">map_option</span> <span class="o">(</span><span class="n">get_root</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">walk</span> <span class="mi">0</span> <span class="o">(</span><span class="nc">Some</span> <span class="n">n</span><span class="o">))</span> <span class="bp">()</span>
</pre></div>
</div>
<p>The first auxiliary function  <code class="docutils literal notranslate"><span class="pre">print_node_with_spaces</span></code> prints a string of <code class="docutils literal notranslate"><span class="pre">s</span></code> spaces and the value of a node <code class="docutils literal notranslate"><span class="pre">l</span></code>.</p>
<p>The second function <code class="docutils literal notranslate"><span class="pre">walk</span></code> traverses the tree recursively, accumulating the “offset” proportionally to the depth of the tree node. It first prints the right sub-tree, then the node itself and then the left sub-tree, making use of the accumulated offset for printing the necessary number of spaces. Finally, it runs <code class="docutils literal notranslate"><span class="pre">walk</span></code> for the top-level root node, if it exists.</p>
<p>Let us observe the effect of <code class="docutils literal notranslate"><span class="pre">print_tree</span></code> by instantiating it to print trees of key-value pairs:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">print_kv_tree</span> <span class="o">=</span> <span class="n">print_tree</span>
    <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;(%d, %s)&quot;</span> <span class="n">k</span> <span class="n">v</span><span class="o">)</span> <span class="mi">12</span>
</pre></div>
</div>
<p>We can now use <code class="docutils literal notranslate"><span class="pre">utop</span></code> to experiment with it:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">utop</span> <span class="o">#</span> <span class="k">open</span> <span class="nc">BST</span><span class="o">;;</span>
<span class="n">utop</span> <span class="o">#</span> <span class="k">open</span> <span class="nc">BinarySearchTree</span><span class="o">;;</span>
<span class="n">utop</span> <span class="o">#</span> <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mk_tree</span> <span class="bp">()</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">t</span> <span class="o">:</span> <span class="k">&#39;</span><span class="o">_</span><span class="n">weak1</span> <span class="n">tree</span> <span class="o">=</span> <span class="o">{</span><span class="n">root</span> <span class="o">=</span> <span class="o">{</span><span class="n">contents</span> <span class="o">=</span> <span class="nc">None</span><span class="o">}}</span>
<span class="n">utop</span> <span class="o">#</span> <span class="k">let</span> <span class="n">a</span> <span class="o">=</span>
  <span class="o">[|(</span><span class="mi">4</span><span class="o">,</span> <span class="s2">&quot;ayuys&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;cdrhf&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="s2">&quot;ukobi&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="s2">&quot;hwsjs&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="s2">&quot;uyrla&quot;</span><span class="o">);</span>
    <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s2">&quot;uldju&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s2">&quot;rkolw&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;gnzzo&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;nksfe&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="s2">&quot;geevu&quot;</span><span class="o">)|]</span>
<span class="n">utop</span> <span class="o">#</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="mi">9</span> <span class="k">do</span> <span class="n">insert</span> <span class="n">t</span> <span class="n">a</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">done</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
<span class="n">utop</span> <span class="o">#</span> <span class="n">print_kv_tree</span> <span class="n">t</span><span class="o">;;</span>
                        <span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="n">uyrla</span><span class="o">)</span>
                                                <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="n">nksfe</span><span class="o">)</span>
                                    <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="n">gnzzo</span><span class="o">)</span>
            <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="n">cdrhf</span><span class="o">)</span>
                                    <span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">hwsjs</span><span class="o">)</span>
                        <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">ukobi</span><span class="o">)</span>
                                    <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">geevu</span><span class="o">)</span>
<span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="n">ayuys</span><span class="o">)</span>
                        <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">rkolw</span><span class="o">)</span>
            <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">uldju</span><span class="o">)</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">unit</span> <span class="o">=</span> <span class="bp">()</span>
</pre></div>
</div>
<p>That is, on can see that <code class="docutils literal notranslate"><span class="pre">(4,</span> <span class="pre">&quot;ayuys&quot;)</span></code> is the root of the tree, and the whole structure satisfies the BST property.</p>
</div>
<div class="section" id="searching-elements">
<h2>12.1.6. Searching Elements<a class="headerlink" href="#searching-elements" title="Permalink to this headline">¶</a></h2>
<p>We define the <code class="docutils literal notranslate"><span class="pre">search</span></code> function so it would return not just the element, but also the node that contains it. It does so by recursively traversing the tree, while relying on its BST property:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">search</span> <span class="n">t</span> <span class="n">k</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">walk</span> <span class="n">k</span> <span class="n">n</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">nk</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="k">value</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">=</span> <span class="n">nk</span> <span class="k">then</span> <span class="nc">Some</span> <span class="n">n</span>
    <span class="k">else</span> <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">nk</span>
    <span class="k">then</span> <span class="k">match</span> <span class="n">left</span> <span class="n">n</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">walk</span> <span class="n">k</span> <span class="n">l</span>
    <span class="k">else</span> <span class="k">match</span> <span class="n">right</span> <span class="n">n</span> <span class="k">with</span>
      <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="nc">None</span>
      <span class="o">|</span> <span class="nc">Some</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">walk</span> <span class="n">k</span> <span class="n">r</span>
  <span class="k">in</span>
  <span class="n">map_option</span> <span class="o">(</span><span class="n">get_root</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">walk</span> <span class="n">k</span><span class="o">)</span> <span class="nc">None</span>
</pre></div>
</div>
<p>In the absence of the abstract module signature, it is quite dangerous to return
a node (not just <cite>its value</cite>), as one can break the BST properties, by messing
with its mutable components (e.g., reference to left/right children). However,
returning a node also simplifies the implementation of various testing and
manipulation procedures, specifically, deletion of tree nodes.</p>
</div>
<div class="section" id="tree-traversals">
<h2>12.1.7. Tree Traversals<a class="headerlink" href="#tree-traversals" title="Permalink to this headline">¶</a></h2>
<p>There are multiple ways to flatten a tree into a list, which can be convenient for the sake of testing and other inspections.</p>
<p>The simplest way to do it is via an accumulator (implemented as a
mutable queue) and a procedure, known as Depth-First-Search (DFS),
which traverses the tree recursively, following its order (sometimes,
this travelsal is also called <cite>in-order</cite> traversal):</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Queues</span>
<span class="k">open</span> <span class="nc">DLLBasedQueue</span>

<span class="k">let</span> <span class="n">depth_first_search_rec</span> <span class="n">t</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">walk</span> <span class="n">q</span> <span class="n">n</span> <span class="o">=</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">left</span> <span class="n">n</span> <span class="k">with</span>
     <span class="o">|</span> <span class="nc">Some</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">walk</span> <span class="n">q</span> <span class="n">l</span>
     <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
    <span class="n">enqueue</span> <span class="n">q</span> <span class="n">n</span><span class="o">.</span><span class="k">value</span><span class="o">;</span>
    <span class="o">(</span><span class="k">match</span> <span class="n">right</span> <span class="n">n</span> <span class="k">with</span>
     <span class="o">|</span> <span class="nc">Some</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">walk</span> <span class="n">q</span> <span class="n">r</span>
     <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">acc</span> <span class="o">=</span> <span class="o">(</span><span class="n">mk_queue</span> <span class="mi">0</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">map_option</span> <span class="o">(</span><span class="n">get_root</span> <span class="n">t</span><span class="o">)</span> <span class="o">(</span><span class="n">walk</span> <span class="n">acc</span><span class="o">)</span> <span class="bp">()</span><span class="o">;</span>
  <span class="n">queue_to_list</span> <span class="n">acc</span>
</pre></div>
</div>
<p>With the call stack, DFS traverses the tree in a Last-In-First-Out
mode (LIFO). By replacing the implicit stack with an explicit mutable
queue (First-In-First-Out, FIFO), we can obtain an alternative
traversal, known as Breadth-First-Search (BFS), so it would accumulate
tree elements by following its “layers”:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">breadth_first_search_loop</span> <span class="n">t</span> <span class="o">=</span>

  <span class="k">let</span> <span class="n">loop</span> <span class="n">wlist</span> <span class="n">q</span> <span class="n">depth</span> <span class="o">=</span>
    <span class="k">while</span> <span class="n">not</span> <span class="o">(</span><span class="n">is_empty</span> <span class="n">wlist</span><span class="o">)</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">get_exn</span> <span class="o">@@</span> <span class="n">dequeue</span> <span class="n">wlist</span> <span class="k">in</span>
      <span class="o">(</span><span class="k">match</span> <span class="n">left</span> <span class="n">n</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">enqueue</span> <span class="n">wlist</span> <span class="n">l</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
      <span class="n">enqueue</span> <span class="n">q</span> <span class="n">n</span><span class="o">.</span><span class="k">value</span><span class="o">;</span>
      <span class="o">(</span><span class="k">match</span> <span class="n">right</span> <span class="n">n</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">enqueue</span> <span class="n">wlist</span> <span class="n">r</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
    <span class="k">done</span>
  <span class="k">in</span>
  <span class="k">let</span> <span class="n">acc</span> <span class="o">=</span> <span class="o">(</span><span class="n">mk_queue</span> <span class="mi">0</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">wlist</span> <span class="o">=</span> <span class="n">mk_queue</span> <span class="mi">0</span> <span class="k">in</span>
  <span class="o">(</span><span class="k">match</span> <span class="n">get_root</span> <span class="n">t</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="k">begin</span>
      <span class="n">enqueue</span> <span class="n">wlist</span> <span class="n">n</span><span class="o">;</span>
      <span class="n">loop</span> <span class="n">wlist</span> <span class="n">acc</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">end</span><span class="o">);</span>
  <span class="n">queue_to_list</span> <span class="n">acc</span>
</pre></div>
</div>
<p>We can also define all elements of the set in terms of the traversal:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">elements</span> <span class="n">t</span> <span class="o">=</span> <span class="n">breadth_first_search_loop</span> <span class="n">t</span>
</pre></div>
</div>
</div>
<div class="section" id="testing-element-retrieval-and-tree-traversals">
<h2>12.1.8. Testing Element Retrieval and Tree Traversals<a class="headerlink" href="#testing-element-retrieval-and-tree-traversals" title="Permalink to this headline">¶</a></h2>
<p>As we know well how to work with lists, we can use traversals to test each other, as well as the <code class="docutils literal notranslate"><span class="pre">search</span></code> function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(******************************************)</span>
<span class="c">(*          Testing traversals            *)</span>
<span class="c">(******************************************)</span>

<span class="k">let</span> <span class="n">check_elem_in_tree</span> <span class="n">t</span> <span class="n">e</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">search</span> <span class="n">t</span> <span class="n">e</span> <span class="k">in</span>
  <span class="o">(</span><span class="n">get_exn</span> <span class="o">@@</span> <span class="n">n</span><span class="o">).</span><span class="k">value</span> <span class="o">=</span> <span class="n">e</span>

<span class="k">let</span><span class="o">%</span><span class="n">test</span> <span class="s2">&quot;Testing DFS&quot;</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mk_tree_of_size</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">depth_first_search_rec</span> <span class="n">t</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">for_all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">check_elem_in_tree</span> <span class="n">t</span> <span class="n">e</span><span class="o">)</span> <span class="n">l1</span> <span class="o">&amp;&amp;</span>
  <span class="n">sorted</span> <span class="n">l1</span>

<span class="k">let</span><span class="o">%</span><span class="n">test</span> <span class="s2">&quot;Testing BFS&quot;</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mk_tree_of_size</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">depth_first_search_rec</span> <span class="n">t</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">l2</span> <span class="o">=</span> <span class="n">breadth_first_search_loop</span> <span class="n">t</span> <span class="k">in</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">l1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&amp;&amp;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">for_all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">e</span> <span class="n">l2</span><span class="o">)</span> <span class="n">l1</span> <span class="o">&amp;&amp;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">for_all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">e</span> <span class="n">l1</span><span class="o">)</span> <span class="n">l2</span>

<span class="c">(******************************************)</span>
<span class="c">(*          Testing retrieval             *)</span>
<span class="c">(******************************************)</span>

<span class="k">let</span><span class="o">%</span><span class="n">test</span> <span class="s2">&quot;Testing retrieval&quot;</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mk_tree_of_size</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">breadth_first_search_loop</span> <span class="n">t</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="n">l</span> <span class="n">m</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">search</span> <span class="n">t</span> <span class="n">e</span> <span class="k">in</span>
  <span class="n">z</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
</div>
<div class="section" id="more-bst-operations">
<h2>12.1.9. More BST operations<a class="headerlink" href="#more-bst-operations" title="Permalink to this headline">¶</a></h2>
<p>Thanks to its invariant, a BST makes it almost trivial to implement operations, such as</p>
<ul class="simple">
<li>Getting minimum/maximum element in a set representing by a tree</li>
<li>Find a successor/predecessor of an element</li>
</ul>
<p>For instance, finding the minimal element of a <cite>subtree</cite> starting from a node
<code class="docutils literal notranslate"><span class="pre">n</span></code> can be achieved by the following operation:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">find_min_node</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">left</span> <span class="n">n</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">m</span> <span class="o">-&gt;</span> <span class="n">find_min_node</span> <span class="n">m</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">n</span>
</pre></div>
</div>
<p>Notice that this operation does not find the <cite>global</cite> tree-wise
successor of the element in node <cite>n</cite>, although that is also possible
to do in <span class="math notranslate nohighlight">\(O(\log n)\)</span> operations for a tree that is well-balanced
(i.e., not to “tall” and “thin”).</p>
</div>
<div class="section" id="deleting-a-node-from-bst">
<h2>12.1.10. Deleting a node from BST<a class="headerlink" href="#deleting-a-node-from-bst" title="Permalink to this headline">¶</a></h2>
<p>Deletion of a node from a BST is the most complicated operation, as it
requires significant restructuring of the tree in order to maintain
its invariant.</p>
<p>Deletion of a non-leaf node from a tree will require some other node
(along with its subtree) to take its place. This can be achieved by
the following operation for performing “transplantation” of one node
by another:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(* Replacing node U by (optional) node V in T. *)</span>
<span class="k">let</span> <span class="n">transplant</span> <span class="n">t</span> <span class="n">u</span> <span class="n">v</span> <span class="o">=</span>
  <span class="o">(</span><span class="k">match</span> <span class="n">parent</span> <span class="n">u</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">root</span> <span class="o">:=</span> <span class="n">v</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">p</span> <span class="o">-&gt;</span>
    <span class="k">match</span> <span class="n">left</span> <span class="n">p</span> <span class="k">with</span>
    <span class="o">|</span> <span class="nc">Some</span> <span class="n">l</span> <span class="k">when</span> <span class="n">u</span> <span class="o">==</span> <span class="n">l</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">left</span> <span class="o">:=</span> <span class="n">v</span>
    <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">right</span> <span class="o">:=</span> <span class="n">v</span><span class="o">);</span>
  <span class="c">(* Update parent of v *)</span>
  <span class="k">match</span> <span class="n">v</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span> <span class="o">:=</span> <span class="n">parent</span> <span class="n">u</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="bp">()</span>
</pre></div>
</div>
<p>Notice the comparison via <code class="docutils literal notranslate"><span class="pre">when</span> <span class="pre">u</span> <span class="pre">==</span> <span class="pre">l</span></code> in the implementation above.
This is essential: node references must be compared using OCaml’s
“shallow” equality mechanism, as structural “deep” equality on
references (<code class="docutils literal notranslate"><span class="pre">=</span></code>) in the case of linked data structures, such as
BSTs, may lead to errors that are <cite>very</cite> difficult to debug.</p>
<p>Let us now discuss possible scenarios for removing a node <code class="docutils literal notranslate"><span class="pre">z</span></code> from the tree <code class="docutils literal notranslate"><span class="pre">T</span></code> by preserving the BST property.</p>
<ol class="loweralpha simple">
<li>The simplest case is when <code class="docutils literal notranslate"><span class="pre">z</span></code> is a leaf, so we can simply remove it.</li>
<li>The node <code class="docutils literal notranslate"><span class="pre">z</span></code> has no left child. In this case, we can simply replace it by its right child (argue, why this is correct) as on the picture below:</li>
</ol>
<a class="reference internal image-reference" href="_images/delete-b.png"><img alt="_images/delete-b.png" class="align-center" src="_images/delete-b.png" style="width: 700px;" /></a>
<ol class="loweralpha simple" start="3">
<li>A similar situation takes place when <code class="docutils literal notranslate"><span class="pre">z</span></code> has only the left child, which replaces it (via <code class="docutils literal notranslate"><span class="pre">transplant</span></code>):</li>
</ol>
<a class="reference internal image-reference" href="_images/delete-c.png"><img alt="_images/delete-c.png" class="align-center" src="_images/delete-c.png" style="width: 700px;" /></a>
<ol class="loweralpha simple" start="4">
<li>In the case when <code class="docutils literal notranslate"><span class="pre">z</span></code> has two children, we need to look up for
the node that corresponds to its successor in <code class="docutils literal notranslate"><span class="pre">z</span></code>-rooted subtree
wrt. the ordering of elements. In this particular case, such a
successor, <code class="docutils literal notranslate"><span class="pre">y</span></code>, is the immediate right child of <code class="docutils literal notranslate"><span class="pre">z</span></code> that has
no left child itself (convince yourself that in this case <code class="docutils literal notranslate"><span class="pre">y</span></code> is
indeed a successor of <code class="docutils literal notranslate"><span class="pre">z</span></code>), therefore we can transplate <code class="docutils literal notranslate"><span class="pre">y</span></code> to
replace <code class="docutils literal notranslate"><span class="pre">z</span></code>:</li>
</ol>
<a class="reference internal image-reference" href="_images/delete-d.png"><img alt="_images/delete-d.png" class="align-center" src="_images/delete-d.png" style="width: 700px;" /></a>
<ol class="loweralpha simple" start="5">
<li>Finally, in the most nasty case, <code class="docutils literal notranslate"><span class="pre">y</span></code>, the successor of <code class="docutils literal notranslate"><span class="pre">z</span></code> (in
its subtree), is buried deep below <code class="docutils literal notranslate"><span class="pre">z</span></code>, and potentially hasa
right child (but no left child, otherwise it wouldn’t be the
successor of <code class="docutils literal notranslate"><span class="pre">z</span></code>) . In this case we need to make to perform the
transformation as follows:</li>
</ol>
<a class="reference internal image-reference" href="_images/delete-e.png"><img alt="_images/delete-e.png" class="align-center" src="_images/delete-e.png" style="width: 700px;" /></a>
<p>Specifically, in the last case we first transplant <code class="docutils literal notranslate"><span class="pre">y</span></code> with its right
child <code class="docutils literal notranslate"><span class="pre">x</span></code> and then make <code class="docutils literal notranslate"><span class="pre">r</span></code>, the former right child of <code class="docutils literal notranslate"><span class="pre">z</span></code> to be
the right child of <code class="docutils literal notranslate"><span class="pre">y</span></code>. After that we simply transplant <code class="docutils literal notranslate"><span class="pre">y</span></code> to the
place of <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
<p>The full code of deletion is as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">delete_node</span> <span class="n">t</span> <span class="n">z</span> <span class="o">=</span>
  <span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">:=</span> <span class="o">!(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
  <span class="k">if</span> <span class="n">left</span> <span class="n">z</span> <span class="o">=</span> <span class="nc">None</span>
  <span class="k">then</span> <span class="n">transplant</span> <span class="n">t</span> <span class="n">z</span> <span class="o">(</span><span class="n">right</span> <span class="n">z</span><span class="o">)</span>
  <span class="k">else</span> <span class="k">if</span> <span class="n">right</span> <span class="n">z</span> <span class="o">=</span> <span class="nc">None</span>
  <span class="k">then</span> <span class="n">transplant</span> <span class="n">t</span> <span class="n">z</span> <span class="o">(</span><span class="n">left</span> <span class="n">z</span><span class="o">)</span>
  <span class="k">else</span>
    <span class="c">(* Finding the successor of `z` *)</span>
    <span class="k">let</span> <span class="n">z_right_child</span> <span class="o">=</span> <span class="o">(</span><span class="n">get_exn</span> <span class="o">@@</span> <span class="n">right</span> <span class="n">z</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">find_min_node</span> <span class="n">z_right_child</span> <span class="k">in</span>
    <span class="c">(* Fact: `y` has no left child *)</span>

    <span class="o">(</span><span class="k">if</span> <span class="n">parent</span> <span class="n">y</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span> <span class="o">&amp;&amp;</span>
        <span class="n">z</span> <span class="o">!=</span> <span class="n">get_exn</span> <span class="o">@@</span> <span class="n">parent</span> <span class="n">y</span>
     <span class="k">then</span>
    <span class="c">(*  If y is not immediately under z,</span>
<span class="c">        replace y by its right subtree *)</span>
       <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="n">right</span> <span class="n">y</span> <span class="k">in</span>
       <span class="o">(</span><span class="n">transplant</span> <span class="n">t</span> <span class="n">y</span> <span class="n">x</span><span class="o">;</span>
        <span class="n">y</span><span class="o">.</span><span class="n">right</span> <span class="o">:=</span> <span class="n">right</span> <span class="n">z</span><span class="o">;</span>
        <span class="o">(</span><span class="n">get_exn</span> <span class="o">@@</span> <span class="n">right</span> <span class="n">y</span><span class="o">).</span><span class="n">parent</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">y</span><span class="o">));</span>

    <span class="c">(* Now `y` replaces `z` at its position *)</span>
    <span class="n">transplant</span> <span class="n">t</span> <span class="n">z</span> <span class="o">(</span><span class="nc">Some</span> <span class="n">y</span><span class="o">);</span>
    <span class="n">y</span><span class="o">.</span><span class="n">left</span> <span class="o">:=</span> <span class="o">!(</span><span class="n">z</span><span class="o">.</span><span class="n">left</span><span class="o">);</span>
    <span class="o">(</span><span class="n">get_exn</span> <span class="o">@@</span> <span class="n">left</span> <span class="n">y</span><span class="o">).</span><span class="n">parent</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">y</span>
</pre></div>
</div>
<p>How would we test deletion? We can do so by generating a random BST,
choosing a random node in it <code class="docutils literal notranslate"><span class="pre">z</span></code>, and then checking the following
properties for the modified tree after the deletion of <code class="docutils literal notranslate"><span class="pre">z</span></code>:</p>
<ul class="simple">
<li>The tree still satisfies the BST invariant;</li>
<li>It has the previous number of elements minus one;</li>
<li>All elements from the modified tree plus the deleted one are the elements of the old tree.</li>
</ul>
<p>These checks can be automatically performed by the following function, parameterised by the size of the tree:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">test_delete</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mk_tree_of_size</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Random</span><span class="p">.</span><span class="n">int</span> <span class="n">n</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">breadth_first_search_loop</span> <span class="n">t</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">nth</span> <span class="n">l</span> <span class="n">m</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">get_exn</span> <span class="o">@@</span> <span class="n">search</span> <span class="n">t</span> <span class="n">e</span> <span class="k">in</span>
  <span class="n">delete_node</span> <span class="n">t</span> <span class="n">z</span><span class="o">;</span>
  <span class="c">(* Checkign the tree invariant *)</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">check_bst_inv</span> <span class="n">t</span><span class="o">);</span>

  <span class="c">(* Checkign the tree size *)</span>
  <span class="k">let</span> <span class="n">ld</span> <span class="o">=</span> <span class="n">breadth_first_search_loop</span> <span class="n">t</span> <span class="k">in</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">ld</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>

  <span class="c">(* Checking integrity *)</span>
  <span class="k">assert</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">for_all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">x</span> <span class="n">ld</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="n">e</span><span class="o">)</span> <span class="n">l</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="bst-rotations">
<h2>12.1.11. BST Rotations<a class="headerlink" href="#bst-rotations" title="Permalink to this headline">¶</a></h2>
<p>In a BST, <em>left and right rotations</em> exchange the node with its right/left child (if present), correspondingly. Diagrammatically, this can be represented by the following picture:</p>
<a class="reference internal image-reference" href="_images/rotations.png"><img alt="_images/rotations.png" class="align-center" src="_images/rotations.png" style="width: 700px;" /></a>
<p>That is, via left rotation, <span class="math notranslate nohighlight">\(y\)</span> becomes a parent of <span class="math notranslate nohighlight">\(x\)</span> and vice versa. The implementation of left rotation of a node <span class="math notranslate nohighlight">\(x\)</span> in a tree <span class="math notranslate nohighlight">\(T\)</span> is given below:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">left_rotate</span> <span class="n">t</span> <span class="n">x</span> <span class="o">=</span>
  <span class="k">match</span> <span class="n">right</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="bp">()</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">y</span> <span class="o">-&gt;</span>

    <span class="c">(* turn y&#39;s left subtree into x&#39;s right subtree *)</span>
    <span class="n">x</span><span class="o">.</span><span class="n">right</span> <span class="o">:=</span> <span class="n">left</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">(</span><span class="k">if</span> <span class="n">left</span> <span class="n">y</span> <span class="o">&lt;&gt;</span> <span class="nc">None</span>
     <span class="k">then</span> <span class="o">(</span><span class="n">get_exn</span> <span class="o">@@</span> <span class="n">left</span> <span class="n">y</span><span class="o">).</span><span class="n">parent</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">x</span><span class="o">);</span>

    <span class="c">(* link x&#39;s parent to y *)</span>
    <span class="n">y</span><span class="o">.</span><span class="n">parent</span> <span class="o">:=</span> <span class="n">parent</span> <span class="n">x</span><span class="o">;</span>

    <span class="o">(</span><span class="k">match</span> <span class="n">parent</span> <span class="n">x</span> <span class="k">with</span>
     <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">root</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">y</span>
     <span class="o">|</span> <span class="nc">Some</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="k">match</span> <span class="n">left</span> <span class="n">p</span> <span class="k">with</span>
       <span class="o">|</span> <span class="nc">Some</span> <span class="n">l</span> <span class="k">when</span> <span class="n">x</span> <span class="o">==</span> <span class="n">l</span> <span class="o">-&gt;</span>
         <span class="n">p</span><span class="o">.</span><span class="n">left</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">y</span>
       <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span>
         <span class="n">p</span><span class="o">.</span><span class="n">right</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">y</span><span class="o">);</span>

    <span class="c">(* Make x the left child of y *)</span>
    <span class="n">y</span><span class="o">.</span><span class="n">left</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">x</span><span class="o">;</span>
    <span class="n">x</span><span class="o">.</span><span class="n">parent</span> <span class="o">:=</span> <span class="nc">Some</span> <span class="n">y</span>
</pre></div>
</div>
<p>When a subtree is rotated, the subtree side upon which it is rotated
increases its height by one node while the other subtree decreases its
height. This makes tree rotations useful for rebalancing a tree when
it becomes “degenerate” (tall and thin). This makes it possible to
keep the worst-case complexity of tree operations within <span class="math notranslate nohighlight">\(O(\log
n)\)</span>, without it degenerating to <span class="math notranslate nohighlight">\(O(n)\)</span>.</p>
<p>Implementation of the right BST rotation and rotation testing of the
rotations are left as an exercise.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="week-11-graphs.html" class="btn btn-neutral float-right" title="12.2. Representing Graphs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="week-11.html" class="btn btn-neutral" title="12. Week 11: Binary Search Trees and Graphs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Ilya Sergey

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"]})</script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>