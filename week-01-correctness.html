

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>3.3. Correctness of Recursive Algorithms &mdash; YSC2229 2020</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3.4. From Recursion to Imperative Loops" href="week-01-loops.html" />
    <link rel="prev" title="3.2. Testing OCaml Code" href="week-01-testing.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> YSC2229: Introductory Data Structures and Algorithms
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="syllabus.html">1. Course Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="prerequisites.html">2. Software Prerequisites</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="lecture-notes-week-01.html">3. Week 01: Introduction</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="week-01-intro.html">3.1. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="week-01-testing.html">3.2. Testing OCaml Code</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.3. Correctness of Recursive Algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#warm-up-finding-a-minimum-in-a-list-of-integers">3.3.1. Warm-up: finding a minimum in a list of integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reasoning-about-termination">3.3.2. Reasoning about termination</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reasoning-about-correctness">3.3.3. Reasoning about correctness</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week-01-loops.html">3.4. From Recursion to Imperative Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="week-01-insert-sort.html">3.5. Sorting Lists via Insertion Sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="week-01-exercises.html">3.6. Exercises</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">YSC2229: Introductory Data Structures and Algorithms</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="lecture-notes-week-01.html">3. Week 01: Introduction</a> &raquo;</li>
        
      <li>3.3. Correctness of Recursive Algorithms</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="correctness-of-recursive-algorithms">
<h1>3.3. Correctness of Recursive Algorithms<a class="headerlink" href="#correctness-of-recursive-algorithms" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>File: <code class="docutils literal notranslate"><span class="pre">Invariants.ml</span></code></li>
</ul>
<p>Data types, present in the modern computer languages, allow one to
provide finite descriptions of arbitrary-size data. As an example of
such description, remember the definition of the list data type in
OCaml, following the grammar:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="kt">list</span><span class="o">-</span><span class="k">of</span><span class="o">-</span><span class="n">things</span><span class="o">&gt;</span> <span class="o">::=</span> <span class="bp">[]</span>
                   <span class="o">|</span> <span class="o">&lt;</span><span class="n">thing</span><span class="o">&gt;</span> <span class="o">::</span> <span class="o">&lt;</span><span class="kt">list</span><span class="o">-</span><span class="k">of</span><span class="o">-</span><span class="n">things</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>That is, to recall, a list is either empty <code class="docutils literal notranslate"><span class="pre">[]</span></code> or constructed by
appending a head <cite>&lt;thing&gt;</cite> to an already constructed list.</p>
<div class="section" id="warm-up-finding-a-minimum-in-a-list-of-integers">
<h2>3.3.1. Warm-up: finding a minimum in a list of integers<a class="headerlink" href="#warm-up-finding-a-minimum-in-a-list-of-integers" title="Permalink to this headline">¶</a></h2>
<p>Being defined recursively, lists are commonly processed by means of
recursive functions (which shouldn’t be too surprising). As a warm-up,
just to remind us what it’s like to work with lists, let us write a
function that walks the list finding its minimal element <code class="docutils literal notranslate"><span class="pre">min</span></code>, and
returns <code class="docutils literal notranslate"><span class="pre">Some</span> <span class="pre">min</span></code>, if it’s found and <code class="docutils literal notranslate"><span class="pre">None</span></code> if the list is
empty:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">find_min</span> <span class="n">ls</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">walk</span> <span class="n">xs</span> <span class="n">min</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">xs</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">min</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">min&#39;</span> <span class="o">=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="k">then</span> <span class="n">h</span> <span class="k">else</span> <span class="n">min</span> <span class="k">in</span>
      <span class="n">walk</span> <span class="n">t</span> <span class="n">min&#39;</span>
  <span class="k">in</span> <span class="k">match</span> <span class="n">ls</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
    <span class="k">let</span> <span class="n">min</span> <span class="o">=</span> <span class="n">walk</span> <span class="n">t</span> <span class="n">h</span> <span class="k">in</span>
    <span class="nc">Some</span> <span class="n">min</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
</div>
<div class="section" id="reasoning-about-termination">
<h2>3.3.2. Reasoning about termination<a class="headerlink" href="#reasoning-about-termination" title="Permalink to this headline">¶</a></h2>
<p>How do we know that <code class="docutils literal notranslate"><span class="pre">find_min</span></code> indeed terminates on every input?
Since the only source of non-termination in functional programs is
recursion, in order to argue for the termination of <code class="docutils literal notranslate"><span class="pre">find_min</span></code> we
have to take a look at its recursive subroutine, namely <code class="docutils literal notranslate"><span class="pre">walk</span></code>. Let
us notice that <code class="docutils literal notranslate"><span class="pre">walk</span></code>, whenever it calls itself recursively, always
does so taking the tail <code class="docutils literal notranslate"><span class="pre">t</span></code> of its initial argument list <code class="docutils literal notranslate"><span class="pre">xs</span></code> as a
new input. Therefore, every time it runs on a <em>smaller</em> list, and
whenever it reaches the empty list <code class="docutils literal notranslate"><span class="pre">[]</span></code>, it simply outputs the
result <code class="docutils literal notranslate"><span class="pre">min</span></code>.</p>
<p>The list argument <code class="docutils literal notranslate"><span class="pre">xs</span></code>, or, more precisely, its size, is commonly
referred to as a <strong>termination measure</strong> or <strong>variant</strong> of a recursive
function. A somewhat more formal definition of <em>variant</em> of a
recursive procedure <code class="docutils literal notranslate"><span class="pre">f</span></code> is a function that maps arguments of <code class="docutils literal notranslate"><span class="pre">f</span></code>
to an integer number <code class="docutils literal notranslate"><span class="pre">n</span></code>, such that every recursive call to <code class="docutils literal notranslate"><span class="pre">f</span></code>
decreases it, such that eventually it reaches some value, which
corresponds to the final step of a computation, at which points the
function terminates, returning the result.</p>
</div>
<div class="section" id="reasoning-about-correctness">
<h2>3.3.3. Reasoning about correctness<a class="headerlink" href="#reasoning-about-correctness" title="Permalink to this headline">¶</a></h2>
<p>How do we know that the function is indeed correct, i.e., does what
it’s supposed to do? A familiar way to probe the implementation for
the <em>presence</em> of bugs is to give the function a specification and
write some tests.</p>
<p>The declarative specification, defined as a function in OCaml, defines
<code class="docutils literal notranslate"><span class="pre">m</span></code> as a minimum for a list <code class="docutils literal notranslate"><span class="pre">ls</span></code>, if <em>all</em> elements of <code class="docutils literal notranslate"><span class="pre">ls</span></code> are
not smaller than <code class="docutils literal notranslate"><span class="pre">m</span></code>, and also <code class="docutils literal notranslate"><span class="pre">m</span></code> is indeed an element of
<code class="docutils literal notranslate"><span class="pre">ls</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">is_min</span> <span class="n">ls</span> <span class="n">m</span> <span class="o">=</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">for_all</span> <span class="o">(</span><span class="k">fun</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="o">)</span> <span class="n">ls</span> <span class="o">&amp;&amp;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">mem</span> <span class="n">m</span> <span class="n">ls</span>
</pre></div>
</div>
<p>Let us now use it in the following specification, which makes use of
the function <code class="docutils literal notranslate"><span class="pre">get_exn</span></code> to <em>unpack</em> the value wrapped into an option
type:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">get_exn</span> <span class="n">o</span> <span class="o">=</span> <span class="k">match</span> <span class="n">o</span> <span class="k">with</span>
  <span class="o">|</span> <span class="nc">Some</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Failure</span> <span class="s2">&quot;Empty result!&quot;</span><span class="o">)</span>

<span class="k">let</span> <span class="n">find_min_spec</span> <span class="n">find_min_fun</span> <span class="n">ls</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">find_min_fun</span> <span class="n">ls</span> <span class="k">in</span>
  <span class="n">ls</span> <span class="o">=</span> <span class="bp">[]</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">None</span> <span class="o">||</span>
  <span class="n">is_min</span> <span class="n">ls</span> <span class="o">(</span><span class="n">get_exn</span> <span class="n">result</span><span class="o">)</span>
</pre></div>
</div>
<p>The specification checker <code class="docutils literal notranslate"><span class="pre">find_min_spec</span></code> is parameterised by both
the function candidate <code class="docutils literal notranslate"><span class="pre">find_min_fun</span></code> to be checked, and a list
<code class="docutils literal notranslate"><span class="pre">ls</span></code> provided as an argument. We can now test is as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="n">find_min_spec</span> <span class="n">find_min</span> <span class="bp">[]</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">find_min_spec</span> <span class="n">find_min</span> <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
<span class="o">#</span> <span class="n">find_min_spec</span> <span class="n">find_min</span> <span class="o">[</span><span class="mi">31</span><span class="o">;</span> <span class="mi">42</span><span class="o">;</span> <span class="mi">239</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">100</span><span class="o">];;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">bool</span> <span class="o">=</span> <span class="bp">true</span>
</pre></div>
</div>
<p>Those test cases are only meaningful if we trust that our
specification <code class="docutils literal notranslate"><span class="pre">find_min_spec</span></code> indeed correctly describes the
expected behaviour of its argument <code class="docutils literal notranslate"><span class="pre">find_min_fin</span></code>. In other words,
to recall, the tests are only as good as the specification they check:
if the specification captures a wrong property or ignores some
essential relations between an input and a result of an algorithm,
then such tests can make more harm than good, giving a false sense of
an implementation not having any issues.</p>
<p>What we really want to ensure is that the recursive <code class="docutils literal notranslate"><span class="pre">walk</span></code> function
processes the lists correctly, iteratively computing the minimum
amongst the list’s elements, getting closer to it with every
iteration. That is, since each “step” of <code class="docutils literal notranslate"><span class="pre">walk</span></code> either returns the
result or recomputes the minimum, for the part of the list <em>already
observed</em>, it would be good to capture it in some form of a
specification.</p>
<p>Such a specification for an arbitrary, possibly recursive, function
<code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span></code> with arguments <code class="docutils literal notranslate"><span class="pre">x1</span></code>, …, <code class="docutils literal notranslate"><span class="pre">xn</span></code> can be captured by
means of a <strong>precondition</strong> and a <strong>postcondition</strong>, which are boolean
functions that play the following role:</p>
<ul class="simple">
<li>A precondition <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span></code> describes the relation between the
arguments of <code class="docutils literal notranslate"><span class="pre">f</span></code> <em>right before</em> <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. It is usually the
duty of the client of the function (i.e., the code that calls it) to
make sure that the precondition holds whenever <code class="docutils literal notranslate"><span class="pre">f</span></code> is about to be
called.</li>
<li>A postcondition <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">res</span></code> describes the relation between
the arguments of <code class="docutils literal notranslate"><span class="pre">f</span></code> and its result right after <code class="docutils literal notranslate"><span class="pre">f</span></code> returns
<code class="docutils literal notranslate"><span class="pre">res</span></code>, being called with <code class="docutils literal notranslate"><span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span></code> as its arguments. It is a
duty of the function implementer of <code class="docutils literal notranslate"><span class="pre">f</span></code> to ensure that the
postcondition holds.</li>
</ul>
<p>Together the pre- and postcondition <code class="docutils literal notranslate"><span class="pre">P</span></code>/<code class="docutils literal notranslate"><span class="pre">Q</span></code> of a function are
frequently referred to as its <strong>contract</strong>, <strong>specification</strong>, or
<strong>invariant</strong>. Even though we will be using those notions
interchangeably, <em>contract</em> is most commonly appears in the context of
dynamic correctness checking (i.e., testing), while <em>invariant</em> is
most commonly used in the context of imperative computations, which we
will see below.</p>
<p>A function <code class="docutils literal notranslate"><span class="pre">f</span></code> is called <strong>correct</strong> with respect to a specification
<code class="docutils literal notranslate"><span class="pre">P</span></code>/<code class="docutils literal notranslate"><span class="pre">Q</span></code>, if whenever its input satisfies <code class="docutils literal notranslate"><span class="pre">P</span></code> (i.e., <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">x1</span> <span class="pre">...</span>
<span class="pre">xn</span> <span class="pre">=</span> <span class="pre">true</span></code>), its result <code class="docutils literal notranslate"><span class="pre">res</span></code> satisfies <code class="docutils literal notranslate"><span class="pre">Q</span></code> (i.e., <code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span>
<span class="pre">res</span> <span class="pre">=</span> <span class="pre">true)</span></code>. The process of checking that an implementation of a
function obeys its ascribed specification is called <strong>program
verification</strong>.</p>
<p>Indeed, any function can be given multiple specifications. For
instance, both <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> can just be constant <code class="docutils literal notranslate"><span class="pre">true</span></code>,
trivially making the function correct. The real power of being able to
ascribe and check the specifications comes from the fact that they
allow to reason about correctness of the computations that employ the
specified function. Let us see how it works on our <code class="docutils literal notranslate"><span class="pre">find_min</span></code>
example.</p>
<p>What should be the pre-/postcondition we should ascribe to <code class="docutils literal notranslate"><span class="pre">walk</span></code>?
That very much depends on what do we want to be true of its result.
Since it’s supposed to deliver the minimum of the list <code class="docutils literal notranslate"><span class="pre">ls</span></code>, it
seems reasonable to fix the postcondition to be as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">find_min_walk_post</span> <span class="n">ls</span> <span class="n">xs</span> <span class="n">min</span> <span class="n">res</span> <span class="o">=</span>
  <span class="n">is_min</span> <span class="n">ls</span> <span class="n">res</span>
</pre></div>
</div>
<p>We can even use it for annotating (via OCaml’s <code class="docutils literal notranslate"><span class="pre">assert</span></code>) the body of
<code class="docutils literal notranslate"><span class="pre">find_min</span></code> making sure that it holds once we return from the
top-level call of <code class="docutils literal notranslate"><span class="pre">walk</span></code>. Notice, that since <code class="docutils literal notranslate"><span class="pre">walk</span></code> is an internal
function of <code class="docutils literal notranslate"><span class="pre">find_min</span></code>, its postcondition also includes <code class="docutils literal notranslate"><span class="pre">ls</span></code>,
which it uses, so it can be considered as another parameter (remember
lambda-lifting?).</p>
<p>Choosing the right precondition for <code class="docutils literal notranslate"><span class="pre">walk</span></code> is somewhat trickier, as
it needs to assist us in showing the two following executions
properties of the function being specified:</p>
<ul class="simple">
<li>In the base case of a recursion (in case of <code class="docutils literal notranslate"><span class="pre">walk</span></code>, it’s the
branch <code class="docutils literal notranslate"><span class="pre">[]</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code>), it trivially gives us the desired property of
the result, i.e., the postcondition holds.</li>
<li>It can be established before the initial and the recursive call.</li>
</ul>
<p>Unfortunately, coming up with the right preconditions for given
postconditions is known to be a work of art. More problematically, it
<em>cannot</em> be automated, and the problem of finding a precondition is
similar to finding good initial hypotheses for theorems in
mathematics. Ironically, this is also one of the problems that itself
is not possible to solve algorithmically: we cannot have an algorithm,
which, given a postcondition and a function, would infer a
precondition for it in a general case. Such a problem, thus is
equivalent to the infamous <a class="reference external" href="https://en.wikipedia.org/wiki/Halting_problem">Halting Problem</a>, but the proof of
such an equivalence is outside the scope of this course.</p>
<p>Nevertheless, we can still try to <em>guess</em> a precondition, and, for
most of the algorithms it is quite feasible. The trick is to look at
the postcondition (i.e., <code class="docutils literal notranslate"><span class="pre">find_min_walk_post</span></code> in our case) as the
“final” state of the computation, and try to guess, from looking at
the initial and intermediate stages, what is different, and who
exactly the program brings us to the state captured by the
postcondition, approaching it gradually as it executes its body.</p>
<p>In the case of <code class="docutils literal notranslate"><span class="pre">walk</span></code>, every iteration (the case <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">::</span> <span class="pre">t</span> <span class="pre">-&gt;</span> <span class="pre">...</span></code>)
recomputes the minium based on the head of the current remaining list.
In this it makes sure that it has the most “up-to-date” value as a
minimum, such that it either is already a global minimum (but we’re
not sure in it yet, as we haven’t seen the rest of the list), or the
minimum is somewhere in the tail yet to be explored. This property is
a reasonable precondition, which we can capture by the following
predicate (i.e., a boolean function):</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">find_min_walk_pre</span> <span class="n">ls</span> <span class="n">xs</span> <span class="n">min</span> <span class="o">=</span>
  <span class="c">(* xs is a suffix of ls *)</span>
  <span class="n">is_suffix</span> <span class="n">xs</span> <span class="n">ls</span> <span class="o">&amp;&amp;</span>
  <span class="o">(</span><span class="c">(* min is a global minimum, *)</span>
   <span class="n">is_min</span> <span class="n">ls</span> <span class="n">min</span> <span class="o">||</span>
   <span class="c">(* or, the minimum is in the remaining tail xs *)</span>
   <span class="nn">List</span><span class="p">.</span><span class="n">exists</span> <span class="o">(</span><span class="k">fun</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">min</span><span class="o">)</span> <span class="n">xs</span><span class="o">)</span>
</pre></div>
</div>
<p>This definition relies on two auxiliary functions:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="k">rec</span> <span class="n">remove_first</span> <span class="n">ls</span> <span class="n">n</span> <span class="o">=</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">ls</span>
  <span class="k">else</span> <span class="k">match</span> <span class="n">ls</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="bp">[]</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span> <span class="n">remove_first</span> <span class="n">t</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span>

<span class="k">let</span> <span class="n">is_suffix</span> <span class="n">xs</span> <span class="n">ls</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">n1</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">xs</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">n2</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">length</span> <span class="n">ls</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">n2</span> <span class="o">-</span> <span class="n">n1</span> <span class="k">in</span>
  <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">then</span> <span class="bp">false</span>
  <span class="k">else</span>
    <span class="k">let</span> <span class="n">ls_tail</span> <span class="o">=</span> <span class="n">remove_first</span> <span class="n">ls</span> <span class="n">diff</span> <span class="k">in</span>
    <span class="n">ls_tail</span> <span class="o">=</span> <span class="n">xs</span>
</pre></div>
</div>
<p>Notice the two critical components of a good precondition:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">find_min_walk_pre</span></code> holds before the first time we call <code class="docutils literal notranslate"><span class="pre">walk</span></code>
from the main function’s body.</li>
<li>Assuming it holds at the beginning of the base case, we know it
implies the desired result <code class="docutils literal notranslate"><span class="pre">is_min</span> <span class="pre">ls</span> <span class="pre">min</span></code>, as the second
component of the disjunction <code class="docutils literal notranslate"><span class="pre">List.exists</span> <span class="pre">(fun</span> <span class="pre">e</span> <span class="pre">-&gt;</span> <span class="pre">e</span> <span class="pre">&lt;</span> <span class="pre">min)</span> <span class="pre">xs</span></code>,
with <code class="docutils literal notranslate"><span class="pre">xs</span> <span class="pre">=</span> <span class="pre">[]</span></code> becomes <code class="docutils literal notranslate"><span class="pre">false</span></code>.</li>
</ul>
<p>What remains is to make sure that the precondition is satisfied at
each recursive call. We can do so by annotating our program suitably
with assertions (it requires small modifications in order to assert
postconditions of the result):</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">find_min_with_invariant</span> <span class="n">ls</span> <span class="o">=</span>

  <span class="k">let</span> <span class="k">rec</span> <span class="n">walk</span> <span class="n">xs</span> <span class="n">min</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">xs</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">min</span> <span class="k">in</span>
      <span class="c">(* Checking the postcondition *)</span>
      <span class="k">assert</span> <span class="o">(</span><span class="n">find_min_walk_post</span> <span class="n">ls</span> <span class="n">xs</span> <span class="n">min</span> <span class="n">res</span><span class="o">);</span>
      <span class="n">res</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">min&#39;</span> <span class="o">=</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="k">then</span> <span class="n">h</span> <span class="k">else</span> <span class="n">min</span> <span class="k">in</span>
      <span class="c">(* Checking the precondition of the recursive call *)</span>
      <span class="k">assert</span> <span class="o">(</span><span class="n">find_min_walk_pre</span> <span class="n">ls</span> <span class="n">t</span> <span class="n">min&#39;</span><span class="o">);</span>
      <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">walk</span> <span class="n">t</span> <span class="n">min&#39;</span> <span class="k">in</span>
      <span class="c">(* Checking the postcondition *)</span>
      <span class="k">assert</span> <span class="o">(</span><span class="n">find_min_walk_post</span> <span class="n">ls</span> <span class="n">xs</span> <span class="n">min</span> <span class="n">res</span><span class="o">);</span>
      <span class="n">res</span>

  <span class="k">in</span> <span class="k">match</span> <span class="n">ls</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
    <span class="c">(* Checking the precondition of the initial call *)</span>
    <span class="k">assert</span> <span class="o">(</span><span class="n">find_min_walk_pre</span> <span class="n">ls</span> <span class="n">t</span> <span class="n">h</span><span class="o">);</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">walk</span> <span class="n">t</span> <span class="n">h</span> <span class="k">in</span>
    <span class="c">(* Checking the postcondition *)</span>
    <span class="k">assert</span> <span class="o">(</span><span class="n">find_min_walk_post</span> <span class="n">ls</span> <span class="n">t</span> <span class="n">h</span> <span class="n">res</span><span class="o">);</span>
    <span class="nc">Some</span> <span class="n">res</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="nc">None</span>
</pre></div>
</div>
<p>Adding the <code class="docutils literal notranslate"><span class="pre">assert</span></code> statements makes us enforce the pre- and
postcondition: had we have guessed them wrongly, a program would crash
on some inputs. For instance, we can change <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> to <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> in the main
iteration of the <code class="docutils literal notranslate"><span class="pre">walk</span></code>, and it will crash. We can now run now
invariant-annotated program as before ensuring that on all provided
test inputs it doesn’t crash and returns the expected results.</p>
<p>Why would the assertion right before the recursive call to <cite>walk</cite>
crash, should we change <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> to <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>? Let us notice that the way
<code class="docutils literal notranslate"><span class="pre">min'</span></code> is computed, it is “adapted” for the updated state, in which
the recursive call is made: specifically, it accounts for the fact
that <code class="docutils literal notranslate"><span class="pre">h</span></code> might have been the new global minimum of <code class="docutils literal notranslate"><span class="pre">ls</span></code> —
something that would have been done wrongly with an opposite
comparison.</p>
<p>Once we have checked the annotation function, we known that on those
test inputs, not only we get the right answers (which could be a sheer
luck), but also at every internal computation step, the main worker
function <code class="docutils literal notranslate"><span class="pre">walk</span></code> maintains a consistent invariant (i.e., satisfies
its pre/postconditions), thus, keeping the computation “on track”
towards the correct outcome.</p>
<p>Does this mean that the function is correct with respect to its
invariant? Unfortunately, even though adding intermediate assertions
gave us stronger confidence in this, the only tool we have at our
disposal are still only tests. In order to gain the full confidence in
the function’s correctness, we would have to use a tool, such as
<a class="reference external" href="https://coq.inria.fr/">Coq</a>. Having pre-/postconditions would also
be very helpful in that case, as they would specify precisely the
induction hypothesis for our correctness proof. However, those
techniques are explained in a course on Functional Programming and
Proving, and we will not be covering them here.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="week-01-loops.html" class="btn btn-neutral float-right" title="3.4. From Recursion to Imperative Loops" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="week-01-testing.html" class="btn btn-neutral" title="3.2. Testing OCaml Code" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ilya Sergey

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>