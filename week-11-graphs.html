

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Representing Graphs &mdash; YSC2229 2021</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> YSC2229: Introductory Data Structures and Algorithms
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="syllabus.html">1. Course Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="prerequisites.html">2. Software Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="codestyle.html">3. OCaml Style Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="week-01.html">1. Week 01: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-02.html">2. Week 02: Working with Arrays</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">YSC2229: Introductory Data Structures and Algorithms</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Representing Graphs</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="representing-graphs">
<span id="graphs"></span><h1>Representing Graphs<a class="headerlink" href="#representing-graphs" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>File <code class="docutils literal notranslate"><span class="pre">Graphs.ml</span></code></li>
</ul>
<p>Graphs are an important versatile mathematical abstraction, which is
used to represent the relations between multiple objects. Such
(possibly non-symmetric) relations can be frequently phrased in terms
of <em>connectivity</em> and <em>reachability</em>, as we’ve seen before in the
chapter on <a class="reference internal" href="week-09-union-find.html#union-find"><span class="std std-ref">Equivalence Classes and Union-Find</span></a>.</p>
<p>A graph is commonly represented in mathematics by a pair <span class="math notranslate nohighlight">\(G =
(V, E)\)</span>, where <span class="math notranslate nohighlight">\(V\)</span> is a set of the graphs’s vertices (nodes),
represented the related elements, and <span class="math notranslate nohighlight">\(E\)</span> is a set of its edges
(arcs) such that <span class="math notranslate nohighlight">\(E \subseteq V \times V\)</span>.</p>
<p>As some graph examples, <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(E\)</span> can represent correspondingly:</p>
<ul class="simple">
<li>Cities and roads between them</li>
<li>Routers in the networks and connections between them</li>
<li>Statements in a program and a control-flow transitions</li>
<li>Control states of a machine and transitions between them</li>
<li>“Friendship” relations between users of a social network</li>
</ul>
<p>It is common to think of <span class="math notranslate nohighlight">\(V\)</span> to be represented by a segment
<span class="math notranslate nohighlight">\(\{0 ... (n - 1)\}\)</span> of natural numbers for some <span class="math notranslate nohighlight">\(n\)</span> (so
that <span class="math notranslate nohighlight">\(n\)</span> is the size of the set of vertices). However, if the
nodes carry additional meaning (e.g., the name of the city), one can
define their payload as a function <span class="math notranslate nohighlight">\(\{0 ... (n - 1)\}
\rightarrow P\)</span> for some set of payload values <span class="math notranslate nohighlight">\(P\)</span>. Edges can be
also given labels in a similar way by defining a function <span class="math notranslate nohighlight">\(E
\rightarrow L\)</span> for some label set <span class="math notranslate nohighlight">\(L\)</span>.</p>
<div class="section" id="graphs-as-adjacency-lists">
<h2>Graphs as Adjacency Lists<a class="headerlink" href="#graphs-as-adjacency-lists" title="Permalink to this headline">¶</a></h2>
<p>Here is the first take on representing graphs as data s structure – by means of <em>adjacency lists</em> (AL). In this representation an each node (a natural number) <code class="docutils literal notranslate"><span class="pre">u</span></code> points (e.g., as an element of an array) to a list of other nodes <code class="docutils literal notranslate"><span class="pre">v</span></code>, that are immediately <em>reachable</em> from <code class="docutils literal notranslate"><span class="pre">u</span></code>, i.e., the graph <code class="docutils literal notranslate"><span class="pre">g</span></code> has an edge <code class="docutils literal notranslate"><span class="pre">(u,</span> <span class="pre">v)</span></code>.</p>
<p>For instance, consider the following graph:</p>
<a class="reference internal image-reference" href="_images/small.png"><img alt="_images/small.png" class="align-center" src="_images/small.png" style="width: 400px;" /></a>
<p>It has 6 nodes (numbered 0-5) and can be encoded via the following array:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">[|[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">3</span><span class="o">];</span>
  <span class="o">[</span><span class="mi">4</span><span class="o">;</span> <span class="mi">2</span><span class="o">];</span>
  <span class="o">[</span><span class="mi">4</span><span class="o">;</span> <span class="mi">5</span><span class="o">];</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">];</span>
  <span class="bp">[]</span><span class="o">;</span>
  <span class="o">[</span><span class="mi">1</span><span class="o">;</span> <span class="mi">5</span><span class="o">]|]</span>
</pre></div>
</div>
<p>That is, for instance, the node 5 has nodes 1 and also itself as its <em>next</em> (successors) nodes, immediately reachable via the corresponding edges.</p>
<p>Keeping in mind the possibility of adding payload to nodes and labels to edges, we arrange the graph as the following type <code class="docutils literal notranslate"><span class="pre">graph</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="nc">AdjacencyGraphs</span> <span class="o">=</span> <span class="k">struct</span>

  <span class="k">type</span> <span class="o">(</span><span class="k">&#39;</span><span class="n">a</span><span class="o">,</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">size</span> <span class="o">:</span> <span class="kt">int</span><span class="o">;</span>
    <span class="n">adj</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="kt">array</span><span class="o">;</span>
    <span class="n">node_payloads</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span><span class="o">)</span> <span class="kt">list</span> <span class="n">ref</span><span class="o">;</span>
    <span class="n">edge_labels</span> <span class="o">:</span> <span class="o">((</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">int</span><span class="o">)</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">b</span><span class="o">)</span> <span class="kt">list</span> <span class="n">ref</span>
  <span class="o">}</span>

  <span class="k">let</span> <span class="n">mk_graph</span> <span class="n">n</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">n</span> <span class="bp">[]</span><span class="o">;</span>
    <span class="n">node_payloads</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span><span class="o">;</span>
    <span class="n">edge_labels</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="c">(* More functions come here *)</span>

<span class="k">end</span>
</pre></div>
</div>
<p>Creating a graph allocates <code class="docutils literal notranslate"><span class="pre">n</span></code> nodes, but does not add any edges. As graphs are an inherently imperative (i.e., mutable) structure, we can add edges as follows by changing the corresponding components of the adjacency array:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">add_edge</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="o">=</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">in_range</span> <span class="n">g</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">in_range</span> <span class="n">g</span> <span class="n">dst</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">src</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">out&#39;</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="n">out</span> <span class="k">in</span>
  <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">src</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">dst</span> <span class="o">::</span> <span class="n">out&#39;</span>
</pre></div>
</div>
<p>That is, the procedure above adds the edges <code class="docutils literal notranslate"><span class="pre">(src,</span> <span class="pre">dst)</span></code> to the graph <code class="docutils literal notranslate"><span class="pre">g</span></code>.</p>
<p>Removing edges or adding labels to them can be achieved in a similar way:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">remove_edge</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="o">=</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">in_range</span> <span class="n">g</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">in_range</span> <span class="n">g</span> <span class="n">dst</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">src</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">out&#39;</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">dst</span><span class="o">)</span> <span class="n">out</span> <span class="k">in</span>
  <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">src</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">out&#39;</span>

<span class="k">let</span> <span class="n">set_edge_label</span> <span class="n">g</span> <span class="n">src</span> <span class="n">dst</span> <span class="n">l</span> <span class="o">=</span>
  <span class="k">assert</span> <span class="o">(</span><span class="n">in_range</span> <span class="n">g</span> <span class="n">src</span> <span class="o">&amp;&amp;</span> <span class="n">in_range</span> <span class="n">g</span> <span class="n">dst</span><span class="o">);</span>
  <span class="k">let</span> <span class="n">labs</span> <span class="o">=</span> <span class="o">!(</span><span class="n">g</span><span class="o">.</span><span class="n">edge_labels</span><span class="o">)</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">labs&#39;</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">((</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">),</span> <span class="o">_)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">&lt;&gt;</span> <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">))</span> <span class="n">labs</span> <span class="k">in</span>
  <span class="n">g</span><span class="o">.</span><span class="n">edge_labels</span> <span class="o">:=</span> <span class="o">((</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">),</span> <span class="n">l</span><span class="o">)</span> <span class="o">::</span> <span class="n">labs&#39;</span>
</pre></div>
</div>
<p>It is not uncommon to need to have the whole set of edges. We can obtain it as follows, by traversing the entire adjacency array, returning the list of edges:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nc">Queues</span>

<span class="k">let</span> <span class="n">edges</span> <span class="n">g</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">open</span> <span class="nc">DLLBasedQueue</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">q</span> <span class="o">=</span> <span class="n">mk_queue</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">adj</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">enqueue</span> <span class="n">q</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">n</span><span class="o">))</span> <span class="n">next</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="n">queue_to_list</span> <span class="n">q</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-and-printing-graphs">
<h2>Reading and Printing Graphs<a class="headerlink" href="#reading-and-printing-graphs" title="Permalink to this headline">¶</a></h2>
<p>Let us now suggest a way to input graphs, so they would be converted to the programmatic representation. One way to do so is to provide a size of a graph (in terms of nodes), as well as all pairs, indicating the directed edges. For instance, the graph above can be defined by the following list of strings, where the first one is its size:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">small_graph_shape</span> <span class="o">=</span>
  <span class="o">[</span><span class="s2">&quot;6&quot;</span><span class="o">;</span>
   <span class="s2">&quot;0 1&quot;</span><span class="o">;</span>
   <span class="s2">&quot;0 3&quot;</span><span class="o">;</span>
   <span class="s2">&quot;3 1&quot;</span><span class="o">;</span>
   <span class="s2">&quot;1 4&quot;</span><span class="o">;</span>
   <span class="s2">&quot;1 2&quot;</span><span class="o">;</span>
   <span class="s2">&quot;2 4&quot;</span><span class="o">;</span>
   <span class="s2">&quot;2 5&quot;</span><span class="o">;</span>
   <span class="s2">&quot;5 1&quot;</span><span class="o">;</span>
   <span class="s2">&quot;5 5&quot;</span><span class="o">]</span>
</pre></div>
</div>
<p>Using the functions from the previous weeks, we can convert this list to a graph, in which node payloads are the same as node identifiers (i.e., natural numbers) using the following function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">adjacency_int_graph_of_strings</span> <span class="n">ls</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="n">trimmer</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">ls</span><span class="o">)</span> <span class="o">|&gt;</span> <span class="n">int_of_string</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">g</span> <span class="o">=</span> <span class="n">mk_graph</span> <span class="n">size</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">edges</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="n">ls</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">pairs</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">trimmer</span> <span class="n">s</span><span class="o">)</span> <span class="n">edges</span> <span class="o">|&gt;</span>
              <span class="nn">List</span><span class="p">.</span><span class="n">filter</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">|&gt;</span>
              <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">s</span> <span class="o">-&gt;</span>
                <span class="k">let</span> <span class="n">splitted</span> <span class="o">=</span> <span class="n">splitter</span> <span class="n">s</span> <span class="k">in</span>
                <span class="k">let</span> <span class="n">src</span> <span class="o">=</span> <span class="n">int_of_string</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">splitted</span> <span class="k">in</span>
                <span class="k">let</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">int_of_string</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="n">splitted</span> <span class="k">in</span>
                <span class="o">(</span><span class="n">src</span><span class="o">,</span> <span class="n">dst</span><span class="o">))</span>
  <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="n">set_payload</span> <span class="n">g</span> <span class="n">i</span> <span class="n">i</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="nn">List</span><span class="p">.</span><span class="n">iter</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">add_edge</span> <span class="n">g</span> <span class="n">s</span> <span class="n">d</span><span class="o">)</span> <span class="n">pairs</span><span class="o">;</span>
  <span class="n">g</span>
</pre></div>
</div>
<p>In the same way, we can read a graph from the file (hence the string-based representation):</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">read_simple_graph_shape_from_file</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">read_file_to_strings</span> <span class="n">filename</span> <span class="k">in</span>
  <span class="n">adjacency_int_graph_of_strings</span> <span class="n">ls</span>
</pre></div>
</div>
<p>Finally, we can dump a simple graph with no payloads into a file using the following pair of functions:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">graph_to_string</span> <span class="n">g</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">string_of_int</span> <span class="n">g</span><span class="o">.</span><span class="n">size</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">ls</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">-&gt;</span>
    <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;%d %d&quot;</span> <span class="n">s</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">edges</span> <span class="n">g</span><span class="o">)</span> <span class="k">in</span>
  <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">(</span><span class="n">s0</span> <span class="o">::</span> <span class="n">ls</span><span class="o">)</span>

<span class="c">(* Dump graph to file *)</span>
<span class="k">let</span> <span class="n">write_simple_graph_shape_to_file</span> <span class="n">filename</span> <span class="n">g</span> <span class="o">=</span>
  <span class="n">graph_to_string</span> <span class="n">g</span> <span class="o">|&gt;</span>
  <span class="n">write_string_to_file</span> <span class="n">filename</span>
</pre></div>
</div>
<p><strong>Question:</strong> How would you suggest to serialize graphs with non-trivial payloads on nodes and labels on edges?</p>
</div>
<div class="section" id="rendering-graphs-via-graphviz">
<h2>Rendering Graphs via GraphViz<a class="headerlink" href="#rendering-graphs-via-graphviz" title="Permalink to this headline">¶</a></h2>
<p>The simplest way to visualise graphs in a nice form is to use a
third-party tool <a class="reference external" href="https://www.graphviz.org/">GraphViz</a>. As input,
GraphViz accepts a text file in a special format, which it can then
convert to an image of a graph, taking care of positioning the nodes
and rendering the edges between them. Some examples ony using GraphViz
can be found by <a class="reference external" href="https://graphs.grevian.org/example">this link</a>.</p>
<p>The following functions transform a graph, represented by adjacency lists to a GraphViz-formatted string and write it to the file:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">graphviz_string_of_graph</span> <span class="n">gtyp</span> <span class="n">conn</span> <span class="n">vattrib</span> <span class="n">eattrib</span> <span class="n">g</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">preamble</span> <span class="o">=</span> <span class="n">gtyp</span> <span class="o">^</span> <span class="s2">&quot; {</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">epilogue</span> <span class="o">=</span> <span class="s2">&quot;}&quot;</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">body</span> <span class="o">=</span>
    <span class="nn">AdjacencyGraphs</span><span class="p">.</span><span class="n">edges</span> <span class="n">g</span> <span class="o">|&gt;</span>
    <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="o">-&gt;</span>
        <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;%s %s %s %s&quot;</span>
          <span class="o">(</span><span class="n">vattrib</span> <span class="n">s</span><span class="o">)</span> <span class="n">conn</span> <span class="o">(</span><span class="n">vattrib</span> <span class="n">d</span><span class="o">)</span> <span class="o">(</span><span class="n">eattrib</span> <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">d</span><span class="o">)))</span> <span class="o">|&gt;</span>
    <span class="nn">String</span><span class="p">.</span><span class="n">concat</span> <span class="s2">&quot;;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="k">in</span>
  <span class="n">preamble</span> <span class="o">^</span> <span class="n">body</span> <span class="o">^</span> <span class="n">epilogue</span>

<span class="k">let</span> <span class="n">graphviz_no_payload</span> <span class="n">g</span> <span class="n">out</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">graphviz_string_of_graph</span> <span class="s2">&quot;digraph&quot;</span> <span class="s2">&quot; -&gt; &quot;</span>
      <span class="n">string_of_int</span> <span class="o">(</span><span class="k">fun</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span><span class="o">)</span> <span class="n">g</span> <span class="k">in</span>
  <span class="n">write_string_to_file</span> <span class="n">out</span> <span class="n">s</span>
</pre></div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">graphviz_string_of_graph</span></code> takes many arguments:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">*</span> <span class="o">``</span><span class="n">gtyp</span><span class="o">``</span> <span class="n">is</span> <span class="n">the</span> <span class="k">type</span> <span class="k">of</span> <span class="n">the</span> <span class="n">graph</span> <span class="k">to</span> <span class="n">be</span> <span class="n">rendered</span> <span class="o">(</span><span class="n">directed</span><span class="o">/</span><span class="n">undirected</span><span class="o">);</span>
<span class="o">*</span> <span class="o">``</span><span class="n">conn</span><span class="o">``</span> <span class="n">is</span> <span class="n">a</span> <span class="n">connective</span> <span class="n">determining</span> <span class="n">the</span> <span class="n">shape</span> <span class="k">of</span> <span class="n">edges</span><span class="o">;</span>
<span class="o">*</span> <span class="o">``</span><span class="n">vattrib</span><span class="o">``</span> <span class="n">is</span> <span class="n">a</span> <span class="k">function</span> <span class="k">to</span> <span class="n">render</span> <span class="n">nodes</span><span class="o">;</span>
<span class="o">*</span> <span class="o">``</span><span class="n">eattrib</span><span class="o">``</span> <span class="n">is</span> <span class="n">a</span> <span class="k">function</span> <span class="k">to</span> <span class="n">render</span> <span class="n">edges</span><span class="o">;</span>
<span class="o">*</span> <span class="o">``</span><span class="n">g</span><span class="o">``</span> <span class="n">is</span> <span class="n">a</span> <span class="n">graph</span> <span class="n">itself</span> <span class="k">in</span> <span class="n">an</span> <span class="n">adjacency</span><span class="o">-</span><span class="kt">list</span> <span class="n">representation</span>
</pre></div>
</div>
<p>When run <code class="docutils literal notranslate"><span class="pre">graphviz_no_payload</span> <span class="pre">g</span> <span class="pre">&quot;graph.dot&quot;</span></code> produces a file named <code class="docutils literal notranslate"><span class="pre">graph.dot</span></code>, which can be then rendered from the console via GraphViz-provided utility <code class="docutils literal notranslate"><span class="pre">dot</span></code> as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="n">dot</span> <span class="o">-</span><span class="nc">Tpdf</span> <span class="n">filename</span><span class="o">.</span><span class="n">dot</span> <span class="o">-</span><span class="n">o</span> <span class="n">outfile</span><span class="o">.</span><span class="n">pdf</span>
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">filename.dot</span></code> can be any GraphViz-formatted file (can be also named differently), and <code class="docutils literal notranslate"><span class="pre">outfile.pdf</span></code> is the resulting PDF file with the graph.</p>
<p>The image above has been obtained via GraphViz for the graph, read from <code class="docutils literal notranslate"><span class="pre">small_graph_shape</span></code>.</p>
</div>
<div class="section" id="shortcomings-of-adjacency-list-graph-representation">
<h2>Shortcomings of Adjacency-List graph representation<a class="headerlink" href="#shortcomings-of-adjacency-list-graph-representation" title="Permalink to this headline">¶</a></h2>
<p>The main disadvantage of adjacency-list based representation is that
the operations of adding an edge, getting successors (and possibly
predecessors) of a node in it are very expensive: all of those
operations take <span class="math notranslate nohighlight">\(O(|V|)\)</span> time. It is also very difficult to add
new nodes, as it would require allocating a new array.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2021, Ilya Sergey

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"]})</script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>