

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Binary Encoding of Data &mdash; YSC2229 2020</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> YSC2229: Introductory Data Structures and Algorithms
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="syllabus.html">1. Course Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="prerequisites.html">2. Software Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-01.html">3. Week 01: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-02.html">4. Week 02: Array Sorting and Order Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-03.html">5. Week 03: Complexity of Recursive Algorithms; Array Generators</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-04.html">6. Week 04: Divide-and-Conquer Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-05.html">7. Week 05: Binary Heaps and Priority Queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-06.html">8. Week 06: Abstract Data Types</a></li>
<li class="toctree-l1"><a class="reference internal" href="midterm.html">9. Midterm Project: Memory Allocation and Reclamation</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-07.html">10. Week 07: Hashing-Based Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-08.html">11. Week 08: Searching in Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-09.html">12. Week 09: Backtracking and Dynamic Programming</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">YSC2229: Introductory Data Structures and Algorithms</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Binary Encoding of Data</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="binary-encoding-of-data">
<span id="week-10-binary"></span><h1>Binary Encoding of Data<a class="headerlink" href="#binary-encoding-of-data" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>File: <code class="docutils literal notranslate"><span class="pre">BinaryEncodings.ml</span></code></li>
</ul>
<p>As discussed in the previous section, there is no big difference between text and binary files, as all of those are represented similarly by sequences of bits, with the former being given a special treatment in the case if an operational system identifies them following a certain encoding pattern.</p>
<p>Let us now learn how to work with binary data (i.e., reading/writing the corresponding files) in OCaml. We will largely rely on the library <code class="docutils literal notranslate"><span class="pre">Extlib.IO</span></code> that comes as a part of the <code class="docutils literal notranslate"><span class="pre">batteries</span></code> package:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">open</span> <span class="nn">Extlib</span><span class="p">.</span><span class="nc">IO</span>
</pre></div>
</div>
<p>The standard terminology for writing/reading data to/from its binary representation is to <em>serialize</em>/<em>deserialize</em> it.</p>
<div class="section" id="writing-and-reading-binary-files">
<h2>Writing and Reading Binary Files<a class="headerlink" href="#writing-and-reading-binary-files" title="Permalink to this headline">¶</a></h2>
<p>Standard OCaml library does not provide means to work with binary data explicitly: with standard functions one can read/write sequences of bits that are multipliers of 8 (i.e., bytes etc), but not individual bits. The functions <code class="docutils literal notranslate"><span class="pre">output_bits</span></code> and <code class="docutils literal notranslate"><span class="pre">input_bits</span></code> from <code class="docutils literal notranslate"><span class="pre">Extlib.IO</span></code> provide this possibility by giving “wrappers” around standard input/output channels for manipulating with files.</p>
<p>The following function, implemented by us, uses <code class="docutils literal notranslate"><span class="pre">input_bits</span></code> to read bits from a file <code class="docutils literal notranslate"><span class="pre">filename</span></code> and process them via the client-provided function <code class="docutils literal notranslate"><span class="pre">deseiralize</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">read_from_binary</span> <span class="n">deserialize</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="nn">Core</span><span class="p">.</span><span class="nn">In_channel</span><span class="p">.</span><span class="n">with_file</span> <span class="o">~</span><span class="n">binary</span><span class="o">:</span><span class="bp">true</span> <span class="n">filename</span>
    <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">file_input</span> <span class="o">-&gt;</span>
        <span class="k">let</span> <span class="n">bits_input</span> <span class="o">=</span> <span class="n">input_bits</span> <span class="o">@@</span> <span class="n">input_channel</span> <span class="n">file_input</span> <span class="k">in</span>
        <span class="n">deserialize</span> <span class="n">bits_input</span><span class="o">)</span>
</pre></div>
</div>
<p>Writing bits to a file is almost as straightforward and is done with the help of the following function that makes use of the <code class="docutils literal notranslate"><span class="pre">output_bits</span></code> wrapper:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">write_to_binary</span> <span class="n">serialize</span> <span class="n">filename</span> <span class="n">data</span> <span class="o">=</span>
  <span class="nn">Core</span><span class="p">.</span><span class="nn">Out_channel</span><span class="p">.</span><span class="n">with_file</span> <span class="n">filename</span> <span class="o">~</span><span class="n">append</span><span class="o">:</span><span class="bp">false</span> <span class="o">~</span><span class="n">binary</span><span class="o">:</span><span class="bp">true</span> <span class="o">~</span><span class="n">f</span><span class="o">:(</span><span class="k">fun</span> <span class="n">file</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="n">bits_output</span> <span class="o">=</span> <span class="n">output_bits</span> <span class="o">@@</span> <span class="n">output_channel</span> <span class="n">file</span> <span class="o">~</span><span class="n">cleanup</span><span class="o">:</span><span class="bp">true</span> <span class="k">in</span>
      <span class="n">serialize</span> <span class="n">bits_output</span> <span class="n">data</span><span class="o">;</span>
      <span class="c">(* Padding from the end -- important! *)</span>
      <span class="n">flush_bits</span> <span class="n">bits_output</span><span class="o">)</span>
</pre></div>
</div>
<p>Notice the last statement <code class="docutils literal notranslate"><span class="pre">flush_bits</span> <span class="pre">bits_output</span></code>. What it does is to add “missing” bits (as zeroes) to the binary file so its length (in bits) would be divisible by 8. If this is not done, then reading such a file might result in an error. The procedure <code class="docutils literal notranslate"><span class="pre">write_to_binary</span></code> takes as arguments, the function <code class="docutils literal notranslate"><span class="pre">serialize</span></code> that handles the data to be written to an output file , the <code class="docutils literal notranslate"><span class="pre">filename</span></code> of the file and the <code class="docutils literal notranslate"><span class="pre">data</span></code> itself.</p>
</div>
<div class="section" id="writing-and-reading-ocaml-strings">
<h2>Writing and Reading OCaml Strings<a class="headerlink" href="#writing-and-reading-ocaml-strings" title="Permalink to this headline">¶</a></h2>
<p>Let us now use the binary-manipulating machinery to read/write OCaml strings as if they were just sequences of bits.</p>
<p>Writing is done via the following function:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">write_string_to_binary</span> <span class="n">filename</span> <span class="n">text</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">serialize</span> <span class="n">out</span> <span class="n">text</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">text</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">int_of_char</span> <span class="n">text</span><span class="o">.[</span><span class="n">i</span><span class="o">]</span> <span class="k">in</span>
      <span class="n">write_bits</span> <span class="n">out</span> <span class="o">~</span><span class="n">nbits</span><span class="o">:</span><span class="mi">8</span> <span class="n">ch</span><span class="o">;</span>
    <span class="k">done</span>
  <span class="k">in</span>
  <span class="n">write_to_binary</span> <span class="n">serialize</span> <span class="n">filename</span> <span class="n">text</span>
</pre></div>
</div>
<p>The implementation above has a couple of interesting aspects. First, it treats a string as an array of characters that it converts to integers (<code class="docutils literal notranslate"><span class="pre">int_of_char</span> <span class="pre">text.[i]</span></code>). Second, it writes those integers as bits (i.e., 8-bit sequence) into the output file <code class="docutils literal notranslate"><span class="pre">out</span></code> (<code class="docutils literal notranslate"><span class="pre">write_bits</span> <span class="pre">out</span> <span class="pre">~nbits:8</span> <span class="pre">ch</span></code>). Since OCaml uses 32 bits to represent integers, such a truncation to 8 bits could be unsafe, but we know that our integers are converted from <code class="docutils literal notranslate"><span class="pre">char</span></code> and hence range at <code class="docutils literal notranslate"><span class="pre">0-255</span></code>.</p>
<p>The resulting file thus contains a sequence of bytes precisely encoding the string.</p>
<p>Reading is done similarly:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">read_string_from_binary</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">deserialize</span> <span class="n">input</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="k">in</span>
    <span class="o">(</span><span class="k">try</span>
       <span class="k">while</span> <span class="bp">true</span> <span class="k">do</span>
         <span class="k">let</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">read_bits</span> <span class="n">input</span> <span class="mi">8</span> <span class="k">in</span>
         <span class="k">let</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">char_of_int</span> <span class="n">bits</span> <span class="k">in</span>
         <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">ch</span>
       <span class="k">done</span><span class="o">;</span>
     <span class="k">with</span> <span class="nn">BatInnerIO</span><span class="p">.</span><span class="nc">No_more_input</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
    <span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buffer</span>
  <span class="k">in</span>
  <span class="n">read_from_binary</span> <span class="n">deserialize</span> <span class="n">filename</span>
</pre></div>
</div>
<p>For an arbitrary file, we don’t know what is the length of the string it has. Therefore, we just keep adding byte-encoded characters to a buffer in a <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">true</span></code> loop, until we hit the end file (each invocation of <code class="docutils literal notranslate"><span class="pre">read_bits</span></code> advances our reading “position” in the file, ultimately reaching the end). Once it happens an exception <code class="docutils literal notranslate"><span class="pre">BatInnerIO.No_more_input</span></code> is raised, which we can catch and  return the result accumulated in the buffer.</p>
<p>We can also test that our serialization is implemented correctly:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">string_serialization_test</span> <span class="n">s</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;text.tmp&quot;</span> <span class="k">in</span>
  <span class="n">write_string_to_binary</span> <span class="n">filename</span> <span class="n">s</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">s&#39;</span> <span class="o">=</span> <span class="n">read_string_from_binary</span> <span class="n">filename</span> <span class="k">in</span>
  <span class="nn">Sys</span><span class="p">.</span><span class="n">remove</span> <span class="n">filename</span><span class="o">;</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">s&#39;</span>

<span class="k">let</span> <span class="n">abracadabra</span> <span class="o">=</span> <span class="s2">&quot;ABRACADABRA!&quot;</span>

<span class="k">let</span><span class="o">%</span><span class="n">test</span> <span class="o">_</span> <span class="o">=</span> <span class="n">string_serialization_test</span> <span class="n">abracadabra</span>
</pre></div>
</div>
<p>For more impressive testing, let us read a large text file (Leo Tolstoy’s “War and Peace”) and make a copy of it, testing the validity of our copying mechanism:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">string_file_serialization_test</span> <span class="n">source_file</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">read_file_to_single_string</span> <span class="n">source_file</span> <span class="k">in</span>
  <span class="n">string_serialization_test</span> <span class="n">s</span>

<span class="c">(* Get the file path *)</span>
<span class="k">let</span> <span class="n">find_file</span> <span class="n">fname</span> <span class="o">=</span>
  <span class="nn">Printf</span><span class="p">.</span><span class="n">sprintf</span> <span class="s2">&quot;%s/%s&quot;</span> <span class="o">(</span><span class="nn">Sys</span><span class="p">.</span><span class="n">getcwd</span> <span class="bp">()</span><span class="o">)</span> <span class="n">fname</span>

<span class="k">let</span><span class="o">%</span><span class="n">test</span> <span class="o">_</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="o">(</span><span class="n">find_file</span> <span class="s2">&quot;../../../resources/war-and-peace.txt&quot;</span><span class="o">)</span> <span class="k">in</span>
  <span class="n">string_file_serialization_test</span> <span class="n">f</span>
</pre></div>
</div>
<p>Notice that the function <code class="docutils literal notranslate"><span class="pre">find_file</span></code> returns the absolute path of a
file located counting from the running directory of the executable.
Here, we have tailored the path so it would work correctly with inline tests.</p>
</div>
<div class="section" id="compressing-dna-sequences">
<h2>Compressing DNA Sequences<a class="headerlink" href="#compressing-dna-sequences" title="Permalink to this headline">¶</a></h2>
<p>There is no gain in reading strings in binary, as we use the same format for representing them as plain OCaml.</p>
<p>Some domains, however, have data, which, which would be too wasteful to represent as strings. Realising this gives an initial idea of implementing <em>data compression</em> — exploiting properties of data to find more compact representation of it as a bit-string.</p>
<p>A good example of data that can be efficiently represented are <a class="reference external" href="https://en.wikipedia.org/wiki/DNA">DNA sequences</a>. The sequences are very long strings of only four characters:</p>
<ul class="simple">
<li>A (Adenosine)</li>
<li>G (Guanine)</li>
<li>C (Cytosine)</li>
<li>T (Thymidine)</li>
</ul>
<p>Therefore, a typical sequences look as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">dna_string1</span> <span class="o">=</span> <span class="s2">&quot;CGT&quot;</span>
<span class="k">let</span> <span class="n">dna_string2</span> <span class="o">=</span> <span class="s2">&quot;ATAGATGCATAGCGCATAGCTAGATAGTGCTAG&quot;</span>
<span class="k">let</span> <span class="n">dna_string3</span> <span class="o">=</span> <span class="s2">&quot;ATAGATGCATAGCGCATAGCTAGATAGTGCTAGCGATGCATAGCGCAGATGCATAGCGCAGGGGG&quot;</span>
<span class="k">let</span> <span class="n">dna_string4</span> <span class="o">=</span> <span class="s2">&quot;ATAGATGCATAGCGCATAGCTAGATAGTGCTAGCGATGCATAGCGCAGATGCATAGCGCAGGGGGATAGATGCATAGCGCATAGCTAGATAGTGCTAGCGATGCATAGCGCAGATGCATAGCGCAGGGGGATAGATGCATAGCGCATAGCTAGATAGTGCTAGCGATGCATAGCGCAGATGCATAGCGCAGGGGGATAGATGCATAGCGCATAGCTAGATAGTGCTAGCGATGCATAGCGCAGATGCATAGCGCAGGGGGATAGATGCATAGCGCATAGCTAGATAGTGCTAGCGATGCATAGCGCAGATGCATAGCGCAGGGGGATAGATGCATAGCGCATAGCTAGATAGTGCTAGCGATGCATAGCGCAGATGCATAGCGCAGGGGG&quot;</span>
</pre></div>
</div>
<p>Since there are only 4 characters in DNA strings, we don’t need 8 bits to encode them — just two bits would do:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">dna_encoding_size</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
<p>We can the implement the encoding from DNA characters to 2-bit integers and vice verse:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">dna_encoder</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="sc">&#39;A&#39;</span> <span class="o">-&gt;</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="sc">&#39;C&#39;</span> <span class="o">-&gt;</span> <span class="mi">1</span>
  <span class="o">|</span> <span class="sc">&#39;G&#39;</span> <span class="o">-&gt;</span> <span class="mi">2</span>
  <span class="o">|</span> <span class="sc">&#39;T&#39;</span> <span class="o">-&gt;</span> <span class="mi">3</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Failure</span> <span class="s2">&quot;DNA encoding error&quot;</span><span class="o">)</span>

<span class="k">let</span> <span class="n">dna_decoder</span> <span class="o">=</span> <span class="k">function</span>
  <span class="o">|</span> <span class="mi">0</span> <span class="o">-&gt;</span> <span class="sc">&#39;A&#39;</span>
  <span class="o">|</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="sc">&#39;C&#39;</span>
  <span class="o">|</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="sc">&#39;G&#39;</span>
  <span class="o">|</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="sc">&#39;T&#39;</span>
  <span class="o">|</span> <span class="o">_</span> <span class="o">-&gt;</span> <span class="k">raise</span> <span class="o">(</span><span class="nc">Failure</span> <span class="s2">&quot;DNA decoding error&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Let us not implement the binary serializers/deserializers for DNA data using this format. This can be accomplished using the general binary-manipulating primitives defined above.</p>
<p>The writing procedure starts by putting a <em>header</em> to the bit file of size 30 (the largest size of a bit-sequence supported by <code class="docutils literal notranslate"><span class="pre">Extlib.IO</span></code>), which is a serialised integer indicating the length of the following sequence of 2-bit encoded DNA characters. We did not need to put this information for 8-bit strings, but need it here because of the file padding via <code class="docutils literal notranslate"><span class="pre">flush_bits</span></code>:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">write_dna_to_binary</span> <span class="n">filename</span> <span class="n">text</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">serialize</span> <span class="n">out</span> <span class="n">text</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">size</span> <span class="o">=</span> <span class="nn">String</span><span class="p">.</span><span class="n">length</span> <span class="n">text</span> <span class="k">in</span>
    <span class="n">write_bits</span> <span class="n">out</span> <span class="o">~</span><span class="n">nbits</span><span class="o">:</span><span class="mi">30</span> <span class="n">size</span><span class="o">;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">let</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">dna_encoder</span> <span class="n">text</span><span class="o">.[</span><span class="n">i</span><span class="o">]</span> <span class="k">in</span>
      <span class="n">write_bits</span> <span class="n">out</span> <span class="o">~</span><span class="n">nbits</span><span class="o">:</span><span class="n">dna_encoding_size</span> <span class="n">ch</span><span class="o">;</span>
    <span class="k">done</span>
  <span class="k">in</span>
  <span class="n">write_to_binary</span> <span class="n">serialize</span> <span class="n">filename</span> <span class="n">text</span>
</pre></div>
</div>
<p>The deserializer proceeds by first retrieving the header and learning the length of the stream of 2-bit characters, and then using this information to read the DNA string into a buffer and return it is OCaml string:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">read_string_from_binary</span> <span class="n">filename</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">deserialize</span> <span class="n">input</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">buffer</span> <span class="o">=</span> <span class="nn">Buffer</span><span class="p">.</span><span class="n">create</span> <span class="mi">1</span> <span class="k">in</span>
    <span class="o">(</span><span class="k">try</span>
       <span class="k">while</span> <span class="bp">true</span> <span class="k">do</span>
         <span class="k">let</span> <span class="n">bits</span> <span class="o">=</span> <span class="n">read_bits</span> <span class="n">input</span> <span class="mi">8</span> <span class="k">in</span>
         <span class="k">let</span> <span class="n">ch</span> <span class="o">=</span> <span class="n">char_of_int</span> <span class="n">bits</span> <span class="k">in</span>
         <span class="nn">Buffer</span><span class="p">.</span><span class="n">add_char</span> <span class="n">buffer</span> <span class="n">ch</span>
       <span class="k">done</span><span class="o">;</span>
     <span class="k">with</span> <span class="nn">BatInnerIO</span><span class="p">.</span><span class="nc">No_more_input</span> <span class="o">-&gt;</span> <span class="bp">()</span><span class="o">);</span>
    <span class="nn">Buffer</span><span class="p">.</span><span class="n">contents</span> <span class="n">buffer</span>
  <span class="k">in</span>
  <span class="n">read_from_binary</span> <span class="n">deserialize</span> <span class="n">filename</span>
</pre></div>
</div>
<p>We can now test our compression/decompression procedure for DNAs:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">dna_compression_test</span> <span class="n">d</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;dna.tmp&quot;</span> <span class="k">in</span>
  <span class="n">write_dna_to_binary</span> <span class="n">filename</span> <span class="n">d</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">d&#39;</span> <span class="o">=</span> <span class="n">read_dna_from_binary</span> <span class="n">filename</span> <span class="k">in</span>
  <span class="nn">Sys</span><span class="p">.</span><span class="n">remove</span> <span class="n">filename</span><span class="o">;</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">d&#39;</span>
</pre></div>
</div>
<p><strong>Question:</strong> How can we see if the compression is beneficial?</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ilya Sergey

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"]})</script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>