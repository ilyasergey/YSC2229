

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.5. Sorting in Linear Time &mdash; YSC2229 2020</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="6.6. Exercises" href="week-04-exercises.html" />
    <link rel="prev" title="6.4. Best-Worst Case for Comparison-Based Sorting" href="week-04-sorting-best-worst.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> YSC2229: Introductory Data Structures and Algorithms
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="syllabus.html">1. Course Syllabus</a></li>
<li class="toctree-l1"><a class="reference internal" href="prerequisites.html">2. Software Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-01.html">3. Week 01: Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-02.html">4. Week 02: Array Sorting and Order Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="week-03.html">5. Week 03: Complexity of Recursive Algorithms; Array Generators</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="week-04.html">6. Week 04: Divide-and-Conquer Algorithms</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="week-04-quicksort.html">6.1. Quicksort and its Variations</a></li>
<li class="toctree-l2"><a class="reference internal" href="week-04-divide-and-conquer-complexity.html">6.2. Complexity of Divide-and-Conquer Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="week-04-comparison-based-sorting.html">6.3. Generalising Comparison-Based Sorting</a></li>
<li class="toctree-l2"><a class="reference internal" href="week-04-sorting-best-worst.html">6.4. Best-Worst Case for Comparison-Based Sorting</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.5. Sorting in Linear Time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#simple-bucket-sort">6.5.1. Simple Bucket Sort</a></li>
<li class="toctree-l3"><a class="reference internal" href="#enhanced-bucket-sort">6.5.2. Enhanced Bucket Sort</a></li>
<li class="toctree-l3"><a class="reference internal" href="#stability-of-sorting">6.5.3. Stability of sorting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#radix-sort">6.5.4. Radix Sort</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="week-04-exercises.html">6.6. Exercises</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">YSC2229: Introductory Data Structures and Algorithms</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="week-04.html">6. Week 04: Divide-and-Conquer Algorithms</a> &raquo;</li>
        
      <li>6.5. Sorting in Linear Time</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sorting-in-linear-time">
<h1>6.5. Sorting in Linear Time<a class="headerlink" href="#sorting-in-linear-time" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li>File: <code class="docutils literal notranslate"><span class="pre">LinearTimeSorting.ml</span></code></li>
</ul>
<p>As we have just determined, one cannot do comparison-based sorting
better than in <span class="math notranslate nohighlight">\(O(n \log n)\)</span> in the worst case. However, we can
improve this complexity if we base the complexity <em>not</em> just on
comparisons, but will also exploit the intrinsic properties of the
data used as keys for elements to be sorted (e.g., integers). In this
chapter we will see some examples of such specialised sorting
procedures.</p>
<div class="section" id="simple-bucket-sort">
<h2>6.5.1. Simple Bucket Sort<a class="headerlink" href="#simple-bucket-sort" title="Permalink to this headline">¶</a></h2>
<p>Bucket sort works well for the case, when the size of the set, from
which we draw the keys is limited by a certain number <cite>bnum</cite>. In this
case, we can allocate an auxiliary array of “buckets” (implemented as
lists), which will serve to collect elements with the key corresponding
to the bucket number. The code is as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">simple_bucket_sort</span> <span class="n">bnum</span> <span class="n">arr</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">bnum</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">fst</span> <span class="n">arr</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">bindex</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">mod</span> <span class="n">bnum</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">bindex</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">buckets</span><span class="o">.(</span><span class="n">bindex</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">::</span> <span class="n">b</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bnum</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">(</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)))</span> <span class="o">!</span><span class="n">res</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="n">list_to_array</span> <span class="o">!</span><span class="n">res</span>
</pre></div>
</div>
<p>Having created an array <code class="docutils literal notranslate"><span class="pre">buckets</span></code>, the sort than traverses the
initial array <code class="docutils literal notranslate"><span class="pre">arr</span></code>, and puts each element with a key <code class="docutils literal notranslate"><span class="pre">key</span></code> into
the bucket with the corresponding index, obtained as <code class="docutils literal notranslate"><span class="pre">bindex</span> <span class="pre">=</span> <span class="pre">key</span>
<span class="pre">mod</span> <span class="pre">bnum</span></code>.  Notice that if the all keys are in range limited by
<code class="docutils literal notranslate"><span class="pre">bnum</span></code>, the <code class="docutils literal notranslate"><span class="pre">mod</span></code> operation returns the key itself.</p>
<p>Therefore, the first <code class="docutils literal notranslate"><span class="pre">for</span></code>-loop has a complexity <span class="math notranslate nohighlight">\(\Theta(n)\)</span>,
where <span class="math notranslate nohighlight">\(n\)</span> is the size of <code class="docutils literal notranslate"><span class="pre">arr</span></code>. The second loop walks through
the array of buckets all the buckets (making <code class="docutils literal notranslate"><span class="pre">bnum</span></code> iterations) and
concatenates all the lists, returning the result as the array. It is
straightforward to show that the resulting complexity of the algorithm
is in <span class="math notranslate nohighlight">\(O(\mathtt{bnum} \cdot n)\)</span>, i.e., it is linear in <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
<p>We can see <code class="docutils literal notranslate"><span class="pre">simple_bucket_sort</span></code> in action:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">c</span> <span class="o">=[|</span><span class="mi">9</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">0</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">3</span><span class="o">|];;</span>

<span class="o">#</span> <span class="n">simple_bucket_sort</span> <span class="mi">10</span> <span class="n">c</span><span class="o">;;</span>
  <span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">0</span><span class="o">;</span> <span class="mi">2</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">4</span><span class="o">;</span> <span class="mi">7</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">9</span><span class="o">|]</span>
</pre></div>
</div>
</div>
<div class="section" id="enhanced-bucket-sort">
<span id="sec-bucket-sort"></span><h2>6.5.2. Enhanced Bucket Sort<a class="headerlink" href="#enhanced-bucket-sort" title="Permalink to this headline">¶</a></h2>
<p>If the size of the space of keys exceeds the number of the buckets,
one can still use the same idea, while also sorting each bucket
individually with a suitable sorting, such as insertion sort
(implemented for lists), as it will be operating on small and almost
sorted sub-arrays:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="c">(* An auxiliary insertion sort on lists *)</span>
<span class="k">let</span> <span class="n">kv_insert_sort</span> <span class="n">ls</span> <span class="o">=</span>
  <span class="k">let</span> <span class="k">rec</span> <span class="n">walk</span> <span class="n">xs</span> <span class="n">acc</span> <span class="o">=</span>
    <span class="k">match</span> <span class="n">xs</span> <span class="k">with</span>
    <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="n">acc</span>
    <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="o">-&gt;</span>
      <span class="k">let</span> <span class="k">rec</span> <span class="n">insert</span> <span class="n">elem</span> <span class="n">remaining</span> <span class="o">=</span>
        <span class="k">match</span> <span class="n">remaining</span> <span class="k">with</span>
        <span class="o">|</span> <span class="bp">[]</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="n">elem</span><span class="o">]</span>
        <span class="o">|</span> <span class="n">h</span> <span class="o">::</span> <span class="n">t</span> <span class="k">as</span> <span class="n">l</span> <span class="o">-&gt;</span>
          <span class="k">if</span> <span class="n">fst</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">fst</span> <span class="n">elem</span>
          <span class="k">then</span> <span class="n">h</span> <span class="o">::</span> <span class="o">(</span><span class="n">insert</span> <span class="n">elem</span> <span class="n">t</span><span class="o">)</span> <span class="k">else</span> <span class="o">(</span><span class="n">elem</span> <span class="o">::</span> <span class="n">l</span><span class="o">)</span>
      <span class="k">in</span>
      <span class="k">let</span> <span class="n">acc&#39;</span> <span class="o">=</span> <span class="n">insert</span> <span class="n">h</span> <span class="n">acc</span> <span class="k">in</span>
      <span class="n">walk</span> <span class="n">t</span> <span class="n">acc&#39;</span>
  <span class="k">in</span>
  <span class="n">walk</span> <span class="n">ls</span> <span class="bp">[]</span>

<span class="k">let</span> <span class="n">bucket_sort</span> <span class="n">max</span> <span class="o">?(</span><span class="n">bnum</span> <span class="o">=</span> <span class="mi">10</span><span class="o">)</span> <span class="n">arr</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">bnum</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">fst</span> <span class="n">arr</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">bind</span> <span class="o">=</span> <span class="n">key</span> <span class="o">*</span> <span class="n">bnum</span> <span class="o">/</span> <span class="n">max</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">bind</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">buckets</span><span class="o">.(</span><span class="n">bind</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">::</span> <span class="n">b</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bnum</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">bucket_contents</span> <span class="o">=</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">(</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">))</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">sorted_bucket</span> <span class="o">=</span> <span class="n">kv_insert_sort</span> <span class="n">bucket_contents</span> <span class="k">in</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="n">sorted_bucket</span> <span class="o">!</span><span class="n">res</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="n">list_to_array</span> <span class="o">!</span><span class="n">res</span>
</pre></div>
</div>
<p>The code of <code class="docutils literal notranslate"><span class="pre">bucket_sort</span></code> above takes an optional parameter <code class="docutils literal notranslate"><span class="pre">bnum</span></code>
for the number of buckets (default is 10, if omitted) and a parameter
<code class="docutils literal notranslate"><span class="pre">max</span></code> to indicate the maximal possible key (should be guessed by the
client of the sorting). When allocating elements to the corresponding
buckets, it divides the entire space of keys (up to the maximal one)
into <code class="docutils literal notranslate"><span class="pre">bnum</span></code> portions, and puts the corresponding element into the
appropriate bucket. Since elements with different keys (from the same
segment) may end up in the same bucket, and additional sorting is
required. This is what is done in the second <code class="docutils literal notranslate"><span class="pre">for</span></code>-loop by means of
<code class="docutils literal notranslate"><span class="pre">kv_insert_sort</span></code>. Let us test this implementation:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">e</span> <span class="o">=</span> <span class="n">generate_int_array</span> <span class="mi">10000</span><span class="o">;;</span>
<span class="k">val</span> <span class="n">e</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">4505</span><span class="o">;</span> <span class="mi">6905</span><span class="o">;</span> <span class="mi">5076</span><span class="o">;</span> <span class="mi">9250</span><span class="o">;</span> <span class="mi">5101</span><span class="o">;</span> <span class="mi">2539</span><span class="o">;</span> <span class="mi">1721</span><span class="o">;</span> <span class="o">...</span> <span class="o">|]</span>

<span class="o">#</span> <span class="n">bucket_sort</span> <span class="mi">10000</span> <span class="n">e</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="kt">array</span> <span class="o">=</span> <span class="o">[|</span><span class="mi">0</span><span class="o">;</span> <span class="mi">1</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">3</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">5</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">6</span><span class="o">;</span> <span class="mi">9</span><span class="o">;</span> <span class="mi">10</span><span class="o">;</span> <span class="o">...</span> <span class="o">|]</span>
</pre></div>
</div>
</div>
<div class="section" id="stability-of-sorting">
<h2>6.5.3. Stability of sorting<a class="headerlink" href="#stability-of-sorting" title="Permalink to this headline">¶</a></h2>
<p>An important property of a sorting algorithm is <strong>stability</strong>. A sorting
algorithms is <em>stable</em> if it preserves the ordering between the elements
with equal keys in the initial array.</p>
<p>An example of a stable sorting algorithm is <code class="docutils literal notranslate"><span class="pre">kv_bucket_sort</span></code> shown
below, which sorts an array of key-value pairs based on the keys:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">kv_bucket_sort</span> <span class="n">bnum</span> <span class="n">arr</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">buckets</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">make</span> <span class="n">bnum</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
    <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">fst</span> <span class="n">arr</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">bindex</span> <span class="o">=</span> <span class="n">key</span> <span class="ow">mod</span> <span class="n">bnum</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buckets</span><span class="o">.(</span><span class="n">bindex</span><span class="o">)</span> <span class="k">in</span>
    <span class="n">buckets</span><span class="o">.(</span><span class="n">bindex</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">arr</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">::</span> <span class="n">b</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ref</span> <span class="bp">[]</span> <span class="k">in</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="n">bnum</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">downto</span> <span class="mi">0</span> <span class="k">do</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="nn">List</span><span class="p">.</span><span class="n">append</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="o">(</span><span class="n">buckets</span><span class="o">.(</span><span class="n">i</span><span class="o">)))</span> <span class="o">!</span><span class="n">res</span>
  <span class="k">done</span><span class="o">;</span>
  <span class="n">list_to_array</span> <span class="o">!</span><span class="n">res</span>
</pre></div>
</div>
<p>As an example, consider its following execution:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="o">#</span> <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="o">[|(</span><span class="mi">3</span><span class="o">,</span> <span class="s2">&quot;zqped&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="s2">&quot;esmup&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;tvqej&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="s2">&quot;xhlzj&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="s2">&quot;blann&quot;</span><span class="o">);</span>
            <span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="s2">&quot;ouors&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s2">&quot;iocvx&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s2">&quot;dacht&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;rncpn&quot;</span><span class="o">);</span>
            <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;khott&quot;</span><span class="o">)|];;</span>

<span class="o">#</span> <span class="n">kv_bucket_sort</span> <span class="mi">10</span> <span class="n">f</span><span class="o">;;</span>
<span class="o">-</span> <span class="o">:</span> <span class="o">(</span><span class="kt">int</span> <span class="o">*</span> <span class="kt">string</span><span class="o">)</span> <span class="kt">array</span> <span class="o">=</span>
<span class="o">[|(</span><span class="mi">0</span><span class="o">,</span> <span class="s2">&quot;iocvx&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s2">&quot;zqped&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="s2">&quot;dacht&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="s2">&quot;blann&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;tvqej&quot;</span><span class="o">);</span>
  <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;rncpn&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="s2">&quot;khott&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="s2">&quot;esmup&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="s2">&quot;xhlzj&quot;</span><span class="o">);</span> <span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="s2">&quot;ouors&quot;</span><span class="o">)|]</span>
</pre></div>
</div>
<p>The initial array has elements <code class="docutils literal notranslate"><span class="pre">(7,</span> <span class="pre">&quot;rncpn&quot;)</span></code> and <code class="docutils literal notranslate"><span class="pre">(7,</span> <span class="pre">&quot;khott&quot;)</span></code>
in this very order. In the same order, the appear in the resulting
array. Other stable sorting algorithm is insertion sort. Not all
sorting algorithms are stable though. Try to answer, whether merge
sort is stable? What about Quicksort?</p>
</div>
<div class="section" id="radix-sort">
<span id="sec-radix-sort"></span><h2>6.5.4. Radix Sort<a class="headerlink" href="#radix-sort" title="Permalink to this headline">¶</a></h2>
<p>The stability comes into play, when one sorting algorithm uses another
one as a black-box, relying on the fact that original order of
elements in partially-sorted arrays with “almost-same” keys will be
preserved.</p>
<p>As an example, radix sort is a linear-time sorting, building on the
idea of bucket-sort, but making it scale logarithmically, which is
necessary if the space of possible keys is too large (e.g., comparable
with the length of an array, in which case bucket sort’s complexity
becomes quadratic). It makes use of bucket sort as its component,
applying it iteratively and sorting a list of integer-keyed elements
<em>per key digit</em>, startgin from the smallest register:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span> <span class="n">radix_sort</span> <span class="n">arr</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">arr</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">max_key</span> <span class="o">=</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ref</span> <span class="mi">0</span> <span class="k">in</span>
    <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
      <span class="k">if</span> <span class="n">arr</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&gt;</span> <span class="o">!</span><span class="n">res</span>
      <span class="k">then</span> <span class="n">res</span> <span class="o">:=</span> <span class="n">arr</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span>
    <span class="k">done</span><span class="o">;</span> <span class="o">!</span><span class="n">res</span>
  <span class="k">in</span>
  <span class="k">if</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">then</span> <span class="n">arr</span>
  <span class="k">else</span>
    <span class="k">let</span> <span class="n">radix</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">max_key</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">array_to_list</span> <span class="n">arr</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">combined</span> <span class="o">=</span> <span class="n">list_to_array</span> <span class="o">(</span><span class="n">list_zip</span> <span class="n">ls</span> <span class="n">ls</span><span class="o">)</span> <span class="k">in</span>
    <span class="k">let</span> <span class="n">res</span> <span class="o">=</span> <span class="n">ref</span> <span class="n">combined</span> <span class="k">in</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">radix</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">do</span>
      <span class="n">res</span> <span class="o">:=</span> <span class="n">kv_bucket_sort</span> <span class="mi">10</span> <span class="o">!</span><span class="n">res</span><span class="o">;</span>
      <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">to</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">do</span>
        <span class="k">let</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">=</span> <span class="o">!</span><span class="n">res</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="k">in</span>
        <span class="o">!</span><span class="n">res</span><span class="o">.(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="o">(</span><span class="n">k</span> <span class="o">/</span> <span class="mi">10</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span>
      <span class="k">done</span><span class="o">;</span>
      <span class="n">radix</span> <span class="o">:=</span> <span class="o">!</span><span class="n">radix</span> <span class="o">/</span> <span class="mi">10</span>
    <span class="k">done</span><span class="o">;</span>
    <span class="k">let</span> <span class="n">result_list</span> <span class="o">=</span> <span class="n">array_to_list</span> <span class="o">!</span><span class="n">res</span> <span class="k">in</span>
    <span class="n">list_to_array</span> <span class="o">@@</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="n">snd</span> <span class="n">result_list</span>
</pre></div>
</div>
<p>It starts by determining the largest key <code class="docutils literal notranslate"><span class="pre">max_key</span></code> in the initial
array. Next, it creates an array <code class="docutils literal notranslate"><span class="pre">combined</span></code>, which pairs all
elements in the original array with their keys. In the <code class="docutils literal notranslate"><span class="pre">while</span></code> loop,
it sorts elements, using <code class="docutils literal notranslate"><span class="pre">kv_bucket_sort</span></code>, based on their digit. It
starts from the lowest register, and then keeps dividing the key
component of each element, “attached” for the sorting purposes, by 10,
repeating the bucket sort, until it runs out of registers.</p>
<p>How many iterations the <code class="docutils literal notranslate"><span class="pre">while</span></code>-loop will make? Notice that each
time it divides the key space by 10, so it will only run for
<span class="math notranslate nohighlight">\(\log_{10}( \mathtt{max\_key})\)</span> iterations. This determines the
complexity of the radix sort, which is, therefore <span class="math notranslate nohighlight">\(O(n
\log(\mathtt{max\_key}))\)</span>, i.e., it is linear if <code class="docutils literal notranslate"><span class="pre">max_key</span></code> is
considered as a constant.</p>
<p>One can test the implementation of radix sort as follows:</p>
<div class="highlight-ocaml notranslate"><div class="highlight"><pre><span></span><span class="k">let</span><span class="o">%</span><span class="n">test</span> <span class="s2">&quot;radix-sort&quot;</span> <span class="o">=</span>
  <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">generate_int_array</span> <span class="mi">1000</span> <span class="k">in</span>
  <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">radix_sort</span> <span class="n">a</span> <span class="k">in</span>
  <span class="n">array_sorted</span> <span class="n">b</span> <span class="o">&amp;&amp;</span>
  <span class="n">same_elems</span> <span class="o">(</span><span class="n">array_to_list</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">array_to_list</span> <span class="n">b</span><span class="o">)</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="week-04-exercises.html" class="btn btn-neutral float-right" title="6.6. Exercises" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="week-04-sorting-best-worst.html" class="btn btn-neutral" title="6.4. Best-Worst Case for Comparison-Based Sorting" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Ilya Sergey

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"extensions": ["tex2jax.js"], "jax": ["input/TeX", "output/HTML-CSS"]})</script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>